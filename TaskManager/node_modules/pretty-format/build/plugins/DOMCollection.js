'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
<<<<<<< HEAD
exports.test = exports.serialize = exports.default = void 0;
var _collections = require('../collections');
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
=======
exports.default = exports.serialize = exports.test = void 0;

var _collections = require('../collections');

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(
        Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        })
      );
    }
    ownKeys.forEach(function(key) {
      _defineProperty(target, key, source[key]);
    });
  }
  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251

const SPACE = ' ';
const OBJECT_NAMES = ['DOMStringMap', 'NamedNodeMap'];
const ARRAY_REGEXP = /^(HTML\w*Collection|NodeList)$/;
<<<<<<< HEAD
const testName = name =>
  OBJECT_NAMES.indexOf(name) !== -1 || ARRAY_REGEXP.test(name);
const test = val =>
  val &&
  val.constructor &&
  !!val.constructor.name &&
  testName(val.constructor.name);
exports.test = test;
const isNamedNodeMap = collection =>
  collection.constructor.name === 'NamedNodeMap';
const serialize = (collection, config, indentation, depth, refs, printer) => {
  const name = collection.constructor.name;
  if (++depth > config.maxDepth) {
    return `[${name}]`;
  }
  return (
    (config.min ? '' : name + SPACE) +
    (OBJECT_NAMES.indexOf(name) !== -1
      ? `{${(0, _collections.printObjectProperties)(
          isNamedNodeMap(collection)
            ? Array.from(collection).reduce((props, attribute) => {
                props[attribute.name] = attribute.value;
                return props;
              }, {})
            : {
                ...collection
              },
=======

const testName = name =>
  OBJECT_NAMES.indexOf(name) !== -1 || ARRAY_REGEXP.test(name);

const test = val =>
  val &&
  val.constructor &&
  val.constructor.name &&
  testName(val.constructor.name); // Convert array of attribute objects to props object.

exports.test = test;

const propsReducer = (props, attribute) => {
  props[attribute.name] = attribute.value;
  return props;
};

const serialize = (collection, config, indentation, depth, refs, printer) => {
  const name = collection.constructor.name;

  if (++depth > config.maxDepth) {
    return '[' + name + ']';
  }

  return (
    (config.min ? '' : name + SPACE) +
    (OBJECT_NAMES.indexOf(name) !== -1
      ? '{' +
        (0, _collections.printObjectProperties)(
          name === 'NamedNodeMap'
            ? Array.prototype.reduce.call(collection, propsReducer, {})
            : _objectSpread({}, collection),
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
          config,
          indentation,
          depth,
          refs,
          printer
<<<<<<< HEAD
        )}}`
      : `[${(0, _collections.printListItems)(
=======
        ) +
        '}'
      : '[' +
        (0, _collections.printListItems)(
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
          Array.from(collection),
          config,
          indentation,
          depth,
          refs,
          printer
<<<<<<< HEAD
        )}]`)
  );
};
=======
        ) +
        ']')
  );
};

>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
exports.serialize = serialize;
const plugin = {
  serialize,
  test
};
var _default = plugin;
exports.default = _default;
