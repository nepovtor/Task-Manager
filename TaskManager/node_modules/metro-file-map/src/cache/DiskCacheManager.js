"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true,
});
exports.DiskCacheManager = void 0;
var _rootRelativeCacheKeys = _interopRequireDefault(
  require("../lib/rootRelativeCacheKeys")
);
<<<<<<< HEAD
var _fs = require("fs");
var _os = require("os");
var _path = _interopRequireDefault(require("path"));
var _timers = require("timers");
var _v = require("v8");
function _interopRequireDefault(e) {
  return e && e.__esModule ? e : { default: e };
}
const debug = require("debug")("Metro:FileMapCache");
const DEFAULT_PREFIX = "metro-file-map";
const DEFAULT_DIRECTORY = (0, _os.tmpdir)();
const DEFAULT_AUTO_SAVE_DEBOUNCE_MS = 5000;
class DiskCacheManager {
  #autoSaveOpts;
  #cachePath;
  #debounceTimeout = null;
  #writePromise = Promise.resolve();
  #hasUnwrittenChanges = false;
  #tryWrite;
  #stopListening;
  constructor(
    { buildParameters },
    { autoSave = {}, cacheDirectory, cacheFilePrefix }
  ) {
    this.#cachePath = DiskCacheManager.getCacheFilePath(
=======
var _gracefulFs = require("graceful-fs");
var _os = require("os");
var _path = _interopRequireDefault(require("path"));
var _v = require("v8");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
const DEFAULT_PREFIX = "metro-file-map";
const DEFAULT_DIRECTORY = (0, _os.tmpdir)();
class DiskCacheManager {
  constructor({ buildParameters, cacheDirectory, cacheFilePrefix }) {
    this._cachePath = DiskCacheManager.getCacheFilePath(
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
      buildParameters,
      cacheFilePrefix,
      cacheDirectory
    );
<<<<<<< HEAD
    if (autoSave) {
      const { debounceMs = DEFAULT_AUTO_SAVE_DEBOUNCE_MS } =
        autoSave === true ? {} : autoSave;
      this.#autoSaveOpts = {
        debounceMs,
      };
    }
=======
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
  }
  static getCacheFilePath(buildParameters, cacheFilePrefix, cacheDirectory) {
    const { rootDirHash, relativeConfigHash } = (0,
    _rootRelativeCacheKeys.default)(buildParameters);
    return _path.default.join(
      cacheDirectory ?? DEFAULT_DIRECTORY,
      `${
        cacheFilePrefix ?? DEFAULT_PREFIX
      }-${rootDirHash}-${relativeConfigHash}`
    );
  }
  getCacheFilePath() {
<<<<<<< HEAD
    return this.#cachePath;
  }
  async read() {
    try {
      return (0, _v.deserialize)(await _fs.promises.readFile(this.#cachePath));
=======
    return this._cachePath;
  }
  async read() {
    try {
      return (0, _v.deserialize)(
        (0, _gracefulFs.readFileSync)(this._cachePath)
      );
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    } catch (e) {
      if (e?.code === "ENOENT") {
        return null;
      }
      throw e;
    }
  }
<<<<<<< HEAD
  async write(
    getSnapshot,
    { changedSinceCacheRead, eventSource, onWriteError }
  ) {
    const tryWrite = (this.#tryWrite = () => {
      this.#writePromise = this.#writePromise
        .then(async () => {
          if (!this.#hasUnwrittenChanges) {
            return;
          }
          const data = getSnapshot();
          this.#hasUnwrittenChanges = false;
          await _fs.promises.writeFile(
            this.#cachePath,
            (0, _v.serialize)(data)
          );
          debug("Written cache to %s", this.#cachePath);
        })
        .catch(onWriteError);
      return this.#writePromise;
    });
    if (this.#autoSaveOpts) {
      const autoSave = this.#autoSaveOpts;
      this.#stopListening?.();
      this.#stopListening = eventSource.onChange(() => {
        this.#hasUnwrittenChanges = true;
        if (this.#debounceTimeout) {
          this.#debounceTimeout.refresh();
        } else {
          this.#debounceTimeout = (0, _timers.setTimeout)(
            () => tryWrite(),
            autoSave.debounceMs
          ).unref();
        }
      });
    }
    if (changedSinceCacheRead) {
      this.#hasUnwrittenChanges = true;
      await tryWrite();
    }
  }
  async end() {
    if (this.#debounceTimeout) {
      (0, _timers.clearTimeout)(this.#debounceTimeout);
    }
    this.#stopListening?.();
    await this.#tryWrite?.();
=======
  async write(dataSnapshot, { changed, removed }) {
    if (changed.size > 0 || removed.size > 0) {
      (0, _gracefulFs.writeFileSync)(
        this._cachePath,
        (0, _v.serialize)(dataSnapshot)
      );
    }
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
  }
}
exports.DiskCacheManager = DiskCacheManager;
