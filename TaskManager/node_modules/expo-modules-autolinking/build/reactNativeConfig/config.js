"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
<<<<<<< HEAD
exports.loadConfigAsync = loadConfigAsync;
=======
exports.loadConfigAsync = void 0;
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
const promises_1 = __importDefault(require("fs/promises"));
const path_1 = __importDefault(require("path"));
const require_from_string_1 = __importDefault(require("require-from-string"));
const resolve_from_1 = __importDefault(require("resolve-from"));
<<<<<<< HEAD
const fileUtils_1 = require("../fileUtils");
let tsMain = undefined;
const mockedNativeModules = path_1.default.join(__dirname, '..', '..', 'node_modules_mock');
=======
const utils_1 = require("./utils");
let tsMain = undefined;
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
/**
 * Load the `react-native.config.js` or `react-native.config.ts` from the package.
 */
async function loadConfigAsync(packageRoot) {
    const configJsPath = path_1.default.join(packageRoot, 'react-native.config.js');
<<<<<<< HEAD
    if (await (0, fileUtils_1.fileExistsAsync)(configJsPath)) {
        return requireConfig(configJsPath, await promises_1.default.readFile(configJsPath, 'utf8'));
    }
    const configTsPath = path_1.default.join(packageRoot, 'react-native.config.ts');
    if (await (0, fileUtils_1.fileExistsAsync)(configTsPath)) {
=======
    if (await (0, utils_1.fileExistsAsync)(configJsPath)) {
        try {
            return require(configJsPath);
        }
        catch {
            return null;
        }
    }
    const configTsPath = path_1.default.join(packageRoot, 'react-native.config.ts');
    if (await (0, utils_1.fileExistsAsync)(configTsPath)) {
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
        if (tsMain === undefined) {
            const tsPath = resolve_from_1.default.silent(packageRoot, 'typescript');
            if (tsPath) {
                tsMain = require(tsPath);
            }
        }
        else if (tsMain == null) {
            return null;
        }
        const configContents = await promises_1.default.readFile(configTsPath, 'utf8');
        const transpiledContents = tsMain?.transpileModule(configContents, {
            compilerOptions: {
                module: tsMain.ModuleKind.NodeNext,
                moduleResolution: tsMain.ModuleResolutionKind.NodeNext,
                target: tsMain.ScriptTarget.ESNext,
            },
        });
        const outputText = transpiledContents?.outputText;
<<<<<<< HEAD
        if (outputText) {
            return requireConfig(configTsPath, outputText);
        }
    }
    return null;
}
/**
 * Temporarily, we need to mock the community CLI, because
 * some packages are checking the version of the CLI in the `react-native.config.js` file.
 * We can remove this once we remove this check from packages.
 */
function requireConfig(filepath, configContents) {
    try {
        const config = (0, require_from_string_1.default)(configContents, filepath, {
            prependPaths: [mockedNativeModules],
        });
        return config.default ?? config ?? null;
    }
    catch {
        return null;
    }
}
=======
        let config;
        try {
            config = outputText ? (0, require_from_string_1.default)(outputText) : null;
        }
        catch { }
        return config?.default ?? config ?? null;
    }
    return null;
}
exports.loadConfigAsync = loadConfigAsync;
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
//# sourceMappingURL=config.js.map