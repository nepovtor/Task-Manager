<<<<<<< HEAD
{"version":3,"file":"urql-exchange-retry.js","sources":["../src/retryExchange.ts"],"sourcesContent":null,"names":["retryExchange","options","retryIf","retryWith","MIN_DELAY","initialDelayMs","MAX_DELAY","maxDelayMs","MAX_ATTEMPTS","maxNumberAttempts","RANDOM_DELAY","randomDelay","forward","dispatchDebug","operations$","source","retry$","next","nextRetryOperation","makeSubject","retryWithBackoff$","mergeMap","operation","retry","context","count","delay","retryCount","delayAmount","backoffFactor","Math","random","min","teardown$","filter","op","kind","key","process","env","NODE_ENV","type","message","data","undefined","takeUntil","debounce","fromValue","makeOperation","res","error","networkError","maxNumberAttemptsExceeded","merge"],"mappings":"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"}
=======
{"version":3,"file":"urql-exchange-retry.js","sources":["../src/retryExchange.ts"],"sourcesContent":["import {\n  makeSubject,\n  share,\n  pipe,\n  merge,\n  filter,\n  fromValue,\n  delay,\n  mergeMap,\n  takeUntil,\n} from 'wonka';\nimport {\n  makeOperation,\n  Exchange,\n  Operation,\n  CombinedError,\n  OperationResult,\n} from '@urql/core';\nimport { sourceT } from 'wonka/dist/types/src/Wonka_types.gen';\n\nexport interface RetryExchangeOptions {\n  initialDelayMs?: number;\n  maxDelayMs?: number;\n  randomDelay?: boolean;\n  maxNumberAttempts?: number;\n  /** Conditionally determine whether an error should be retried */\n  retryIf?: (error: CombinedError, operation: Operation) => boolean;\n  /** Conditionally update operations as they're retried (retryIf can be replaced with this) */\n  retryWith?: (\n    error: CombinedError,\n    operation: Operation\n  ) => Operation | null | undefined;\n}\n\nexport const retryExchange = ({\n  initialDelayMs,\n  maxDelayMs,\n  randomDelay,\n  maxNumberAttempts,\n  retryIf,\n  retryWith,\n}: RetryExchangeOptions): Exchange => {\n  const MIN_DELAY = initialDelayMs || 1000;\n  const MAX_DELAY = maxDelayMs || 15000;\n  const MAX_ATTEMPTS = maxNumberAttempts || 2;\n  const RANDOM_DELAY = randomDelay || true;\n\n  return ({ forward, dispatchDebug }) => ops$ => {\n    const sharedOps$ = pipe(ops$, share);\n    const {\n      source: retry$,\n      next: nextRetryOperation,\n    } = makeSubject<Operation>();\n\n    const retryWithBackoff$ = pipe(\n      retry$,\n      mergeMap((op: Operation) => {\n        const { key, context } = op;\n        const retryCount = (context.retryCount || 0) + 1;\n        let delayAmount = context.retryDelay || MIN_DELAY;\n\n        const backoffFactor = Math.random() + 1.5;\n        // if randomDelay is enabled and it won't exceed the max delay, apply a random\n        // amount to the delay to avoid thundering herd problem\n        if (RANDOM_DELAY && delayAmount * backoffFactor < MAX_DELAY) {\n          delayAmount *= backoffFactor;\n        }\n\n        // We stop the retries if a teardown event for this operation comes in\n        // But if this event comes through regularly we also stop the retries, since it's\n        // basically the query retrying itself, no backoff should be added!\n        const teardown$ = pipe(\n          sharedOps$,\n          filter(op => {\n            return (\n              (op.kind === 'query' || op.kind === 'teardown') && op.key === key\n            );\n          })\n        );\n\n        dispatchDebug({\n          type: 'retryAttempt',\n          message: `The operation has failed and a retry has been triggered (${retryCount} / ${MAX_ATTEMPTS})`,\n          operation: op,\n          data: {\n            retryCount,\n          },\n        });\n\n        // Add new retryDelay and retryCount to operation\n        return pipe(\n          fromValue(\n            makeOperation(op.kind, op, {\n              ...op.context,\n              retryDelay: delayAmount,\n              retryCount,\n            })\n          ),\n          delay(delayAmount),\n          // Stop retry if a teardown comes in\n          takeUntil(teardown$)\n        );\n      })\n    );\n\n    const result$ = pipe(\n      merge([sharedOps$, retryWithBackoff$]),\n      forward,\n      share,\n      filter(res => {\n        // Only retry if the error passes the conditional retryIf function (if passed)\n        // or if the error contains a networkError\n        if (\n          !res.error ||\n          (retryIf\n            ? !retryIf(res.error, res.operation)\n            : !retryWith && !res.error.networkError)\n        ) {\n          return true;\n        }\n\n        const maxNumberAttemptsExceeded =\n          (res.operation.context.retryCount || 0) >= MAX_ATTEMPTS - 1;\n\n        if (!maxNumberAttemptsExceeded) {\n          const operation = retryWith\n            ? retryWith(res.error, res.operation)\n            : res.operation;\n          if (!operation) return true;\n\n          // Send failed responses to be retried by calling next on the retry$ subject\n          // Exclude operations that have been retried more than the specified max\n          nextRetryOperation(operation);\n          return false;\n        }\n\n        dispatchDebug({\n          type: 'retryExhausted',\n          message:\n            'Maximum number of retries has been reached. No further retries will be performed.',\n          operation: res.operation,\n        });\n\n        return true;\n      })\n    ) as sourceT<OperationResult>;\n\n    return result$;\n  };\n};\n"],"names":["MIN_DELAY","initialDelayMs","MAX_DELAY","MAX_ATTEMPTS","RANDOM_DELAY","retryWithBackoff$","retryCount","op","context","delayAmount","retryDelay","backoffFactor","filter","kind","env","message","operation","data","source","error"],"mappings":";;;;;;;;;;;;;;;;;;;;MA0CQA,IAAYC;MACZC;MACAC;MACAC;;;;;;;;;UASEC;;;YAIIC,IAAUC,EAAGC;YACfC,KAAcD,EAAQE,cAAcV;YAElCW;;;;;kBAcaC,QAAZ;UAJQ,sBAAAC;;iCAUPC;UACNC;UACAC,SAAS;UACTC;;;;UAJFC;;;sBAeMZ;UAHWA;;;;gBA0BRa;;;;;;;;;;;iCAmBDL;UACNC;UAEAC,SAAS;;UAJXE;;QA/BS;"}
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
