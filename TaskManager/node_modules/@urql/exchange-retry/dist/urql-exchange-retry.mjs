<<<<<<< HEAD
import { makeSubject as r, mergeMap as e, filter as t, takeUntil as a, debounce as o, fromValue as n, merge as i } from "wonka";

import { makeOperation as u } from "@urql/core";

var retryExchange = (y = {}) => {
  var {retryIf: d, retryWith: s} = y;
  var l = y.initialDelayMs || 1e3;
  var p = y.maxDelayMs || 15e3;
  var m = y.maxNumberAttempts || 2;
  var c = null != y.randomDelay ? !!y.randomDelay : !0;
  return ({forward: y, dispatchDebug: v}) => f => {
    var {source: h, next: x} = r();
    var E = e((r => {
      var e = r.context.retry || {
        count: 0,
        delay: null
      };
      var i = ++e.count;
      var y = e.delay || l;
      var d = Math.random() + 1.5;
      if (c) {
        if (y * d < p) {
          y *= d;
        } else {
          y = p;
        }
      } else {
        y = Math.min(i * l, p);
      }
      e.delay = y;
      var s = t((e => ("query" === e.kind || "teardown" === e.kind) && e.key === r.key))(f);
      "production" !== process.env.NODE_ENV && v({
        type: "retryAttempt",
        message: `The operation has failed and a retry has been triggered (${i} / ${m})`,
        operation: r,
        data: {
          retryCount: i,
          delayAmount: y
        },
        source: "retryExchange"
      });
      return a(s)(o((() => y))(n(u(r.kind, r, {
        ...r.context,
        retry: e
      }))));
    }))(h);
    return t((r => {
      var e = r.operation.context.retry;
      if (!(r.error && (d ? d(r.error, r.operation) : s || r.error.networkError))) {
        if (e) {
          e.count = 0;
          e.delay = null;
        }
        return !0;
      }
      if (!((e && e.count || 0) >= m - 1)) {
        var t = s ? s(r.error, r.operation) : r.operation;
        if (!t) {
          return !0;
        }
        x(t);
        return !1;
      }
      "production" !== process.env.NODE_ENV && v({
        type: "retryExhausted",
        message: "Maximum number of retries has been reached. No further retries will be performed.",
        operation: r.operation,
        source: "retryExchange"
      });
      return !0;
    }))(y(i([ f, E ])));
  };
};
=======
import { share as r, makeSubject as e, mergeMap as t, filter as n, takeUntil as a, delay as o, fromValue as i, merge as u } from "wonka";

import { makeOperation as c } from "@urql/core";

function _extends() {
  return (_extends = Object.assign || function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var n in t) {
        if (Object.prototype.hasOwnProperty.call(t, n)) {
          r[n] = t[n];
        }
      }
    }
    return r;
  }).apply(this, arguments);
}

function retryExchange(s) {
  var y = s.retryIf;
  var p = s.retryWith;
  var v = s.initialDelayMs || 1e3;
  var f = s.maxDelayMs || 15e3;
  var d = s.maxNumberAttempts || 2;
  var h = s.randomDelay || !0;
  return function(s) {
    var m = s.forward;
    var x = s.dispatchDebug;
    return function(s) {
      var l = r(s);
      var g = e();
      var E = g.source;
      var b = g.next;
      var D = t((function(r) {
        var e = r.key;
        var t = r.context;
        var u = (t.retryCount || 0) + 1;
        var s = t.retryDelay || v;
        var y = Math.random() + 1.5;
        if (h && s * y < f) {
          s *= y;
        }
        var p = n((function(r) {
          return ("query" === r.kind || "teardown" === r.kind) && r.key === e;
        }))(l);
        "production" !== process.env.NODE_ENV && x({
          type: "retryAttempt",
          message: "The operation has failed and a retry has been triggered (" + u + " / " + d + ")",
          operation: r,
          data: {
            retryCount: u
          },
          source: "retryExchange"
        });
        return a(p)(o(s)(i(c(r.kind, r, _extends({}, r.context, {
          retryDelay: s,
          retryCount: u
        })))));
      }))(E);
      return n((function(r) {
        if (!(r.error && (y ? y(r.error, r.operation) : p || r.error.networkError))) {
          return !0;
        }
        if (!((r.operation.context.retryCount || 0) >= d - 1)) {
          var e = p ? p(r.error, r.operation) : r.operation;
          if (!e) {
            return !0;
          }
          b(e);
          return !1;
        }
        "production" !== process.env.NODE_ENV && x({
          type: "retryExhausted",
          message: "Maximum number of retries has been reached. No further retries will be performed.",
          operation: r.operation,
          source: "retryExchange"
        });
        return !0;
      }))(r(m(u([ l, D ]))));
    };
  };
}
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251

export { retryExchange };
//# sourceMappingURL=urql-exchange-retry.mjs.map
