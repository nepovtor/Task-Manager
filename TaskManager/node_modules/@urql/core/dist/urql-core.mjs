<<<<<<< HEAD
import { Kind as e } from "@0no-co/graphql.web";

import { k as r, s as t, m as n, C as a, a as o, b as s, c, d as u, e as p, f as d, g as v, h as l } from "./urql-core-chunk.mjs";

export { j as getOperationName, i as stringifyVariables } from "./urql-core-chunk.mjs";

import { toPromise as f, take as h, filter as k, subscribe as y, map as m, tap as x, merge as g, mergeMap as w, takeUntil as O, make as E, onPush as b, share as N, fromPromise as q, fromValue as _, makeSubject as D, lazy as S, onStart as P, switchMap as R, publish as V, takeWhile as A, onEnd as M } from "wonka";

var collectTypes = (e, r) => {
  if (Array.isArray(e)) {
    for (var t = 0, n = e.length; t < n; t++) {
      collectTypes(e[t], r);
    }
  } else if ("object" == typeof e && null !== e) {
    for (var a in e) {
      if ("__typename" === a && "string" == typeof e[a]) {
        r.add(e[a]);
      } else {
        collectTypes(e[a], r);
=======
import { visit as e } from "graphql/language/visitor.mjs";

import { Kind as r } from "graphql/language/kinds.mjs";

import { print as n } from "graphql/language/printer.mjs";

import { k as t, _ as o, s as u, C as c, m as s, a as p, b as l, c as d, d as v, e as y, g as k, f as g } from "./01e1547d.mjs";

export { C as CombinedError, f as createRequest, j as getOperationName, a as makeErrorResult, m as makeResult, i as mergeResultPatch, h as stringifyVariables } from "./01e1547d.mjs";

import { toPromise as x, take as E, filter as O, share as b, map as w, tap as q, merge as N, mergeMap as D, takeUntil as _, make as S, onPush as R, makeSubject as T, subscribe as P, onEnd as M, onStart as A, publish as V, switchMap as I, fromValue as F } from "wonka";

function collectTypes(e, r) {
  if (Array.isArray(e)) {
    for (var n = 0; n < e.length; n++) {
      collectTypes(e[n], r);
    }
  } else if ("object" == typeof e && null !== e) {
    for (var t in e) {
      if ("__typename" === t && "string" == typeof e[t]) {
        r[e[t]] = 0;
      } else {
        collectTypes(e[t], r);
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
      }
    }
  }
  return r;
<<<<<<< HEAD
};

var formatNode = r => {
  if ("definitions" in r) {
    var t = [];
    for (var n = 0, a = r.definitions.length; n < a; n++) {
      var i = formatNode(r.definitions[n]);
      t.push(i);
    }
    return {
      ...r,
      definitions: t
    };
  }
  if ("directives" in r && r.directives && r.directives.length) {
    var o = [];
    var s = {};
    for (var c = 0, u = r.directives.length; c < u; c++) {
      var p = r.directives[c];
      var d = p.name.value;
      if ("_" !== d[0]) {
        o.push(p);
      } else {
        d = d.slice(1);
      }
      s[d] = p;
    }
    r = {
      ...r,
      directives: o,
      _directives: s
    };
  }
  if ("selectionSet" in r) {
    var v = [];
    var l = r.kind === e.OPERATION_DEFINITION;
    if (r.selectionSet) {
      for (var f = 0, h = r.selectionSet.selections.length; f < h; f++) {
        var k = r.selectionSet.selections[f];
        l = l || k.kind === e.FIELD && "__typename" === k.name.value && !k.alias;
        var y = formatNode(k);
        v.push(y);
      }
      if (!l) {
        v.push({
          kind: e.FIELD,
          name: {
            kind: e.NAME,
            value: "__typename"
          },
          _generated: !0
        });
      }
      return {
        ...r,
        selectionSet: {
          ...r.selectionSet,
          selections: v
        }
      };
    }
  }
  return r;
};

var I = new Map;

var formatDocument = e => {
  var t = r(e);
  var n = I.get(t.__key);
  if (!n) {
    I.set(t.__key, n = formatNode(t));
    Object.defineProperty(n, "__key", {
      value: t.__key,
      enumerable: !1
    });
  }
  return n;
};

function withPromise(e) {
  var source$ = r => e(r);
  source$.toPromise = () => f(h(1)(k((e => !e.stale && !e.hasNext))(source$)));
  source$.then = (e, r) => source$.toPromise().then(e, r);
  source$.subscribe = e => y(e)(source$);
  return source$;
}

function makeOperation(e, r, t) {
  return {
    ...r,
    kind: e,
    context: r.context ? {
      ...r.context,
      ...t
    } : t || r.context
  };
}

var addMetadata = (e, r) => makeOperation(e.kind, e, {
  meta: {
    ...e.context.meta,
    ...r
  }
});

var noop = () => {};

function gql(n) {
  var a = new Map;
  var i = [];
  var o = [];
  var s = Array.isArray(n) ? n[0] : n || "";
  for (var c = 1; c < arguments.length; c++) {
    var u = arguments[c];
    if (u && u.definitions) {
      o.push(u);
    } else {
      s += u;
    }
    s += arguments[0][c];
  }
  o.unshift(r(s));
  for (var p = 0; p < o.length; p++) {
    for (var d = 0; d < o[p].definitions.length; d++) {
      var v = o[p].definitions[d];
      if (v.kind === e.FRAGMENT_DEFINITION) {
        var l = v.name.value;
        var f = t(v);
        if (!a.has(l)) {
          a.set(l, f);
          i.push(v);
        } else if ("production" !== process.env.NODE_ENV && a.get(l) !== f) {
          console.warn("[WARNING: Duplicate Fragment] A fragment with name `" + l + "` already exists in this document.\nWhile fragment names may not be unique across your source, each name must be unique per document.");
        }
      } else {
        i.push(v);
      }
    }
  }
  return r({
    kind: e.DOCUMENT,
    definitions: i
  });
}

var shouldSkip = ({kind: e}) => "mutation" !== e && "query" !== e;

var mapTypeNames = e => {
  var r = formatDocument(e.query);
  if (r !== e.query) {
    var t = makeOperation(e.kind, e);
    t.query = r;
    return t;
  } else {
    return e;
  }
};

var cacheExchange = ({forward: e, client: r, dispatchDebug: t}) => {
  var a = new Map;
  var i = new Map;
  var isOperationCached = e => "query" === e.kind && "network-only" !== e.context.requestPolicy && ("cache-only" === e.context.requestPolicy || a.has(e.key));
  return o => {
    var s = m((e => {
      var i = a.get(e.key);
      "production" !== process.env.NODE_ENV && t({
        operation: e,
        ...i ? {
          type: "cacheHit",
          message: "The result was successfully retrieved from the cache"
        } : {
          type: "cacheMiss",
          message: "The result could not be retrieved from the cache"
        },
        source: "cacheExchange"
      });
      var o = i || n(e, {
        data: null
      });
      o = {
        ...o,
        operation: addMetadata(e, {
          cacheOutcome: i ? "hit" : "miss"
        })
      };
      if ("cache-and-network" === e.context.requestPolicy) {
        o.stale = !0;
        reexecuteOperation(r, e);
      }
      return o;
    }))(k((e => !shouldSkip(e) && isOperationCached(e)))(o));
    var c = x((e => {
      var {operation: n} = e;
      if (!n) {
        return;
      }
      var o = n.context.additionalTypenames || [];
      if ("subscription" !== e.operation.kind) {
        o = (e => [ ...collectTypes(e, new Set) ])(e.data).concat(o);
      }
      if ("mutation" === e.operation.kind || "subscription" === e.operation.kind) {
        var s = new Set;
        "production" !== process.env.NODE_ENV && t({
          type: "cacheInvalidation",
          message: `The following typenames have been invalidated: ${o}`,
          operation: n,
=======
}

function collectTypesFromResponse(e) {
  return Object.keys(collectTypes(e, {}));
}

var formatNode = function(e) {
  if (e.selectionSet && !e.selectionSet.selections.some((function(e) {
    return e.kind === r.FIELD && "__typename" === e.name.value && !e.alias;
  }))) {
    return o({}, e, {
      selectionSet: o({}, e.selectionSet, {
        selections: e.selectionSet.selections.concat([ {
          kind: r.FIELD,
          name: {
            kind: r.NAME,
            value: "__typename"
          }
        } ])
      })
    });
  }
};

var Q = new Map;

function formatDocument(r) {
  var n = t(r);
  var a = Q.get(n.__key);
  if (!a) {
    a = e(n, {
      Field: formatNode,
      InlineFragment: formatNode
    });
    Object.defineProperty(a, "__key", {
      value: n.__key,
      enumerable: !1
    });
    Q.set(n.__key, a);
  }
  return a;
}

function maskTypename(e) {
  if (!e || "object" != typeof e) {
    return e;
  }
  return Object.keys(e).reduce((function(r, n) {
    var t = e[n];
    if ("__typename" === n) {
      Object.defineProperty(r, "__typename", {
        enumerable: !1,
        value: t
      });
    } else if (Array.isArray(t)) {
      r[n] = t.map(maskTypename);
    } else if (t && "object" == typeof t && "__typename" in t) {
      r[n] = maskTypename(t);
    } else {
      r[n] = t;
    }
    return r;
  }), Array.isArray(e) ? [] : {});
}

function withPromise(e) {
  e.toPromise = function() {
    return x(E(1)(O((function(e) {
      return !e.stale && !e.hasNext;
    }))(e)));
  };
  return e;
}

function makeOperation(e, r, n) {
  if (!n) {
    n = r.context;
  }
  return {
    key: r.key,
    query: r.query,
    variables: r.variables,
    kind: e,
    context: n
  };
}

function addMetadata(e, r) {
  return makeOperation(e.kind, e, o({}, e.context, {
    meta: o({}, e.context.meta, r)
  }));
}

function noop() {}

function applyDefinitions(e, n, t) {
  for (var a = 0; a < t.length; a++) {
    if (t[a].kind === r.FRAGMENT_DEFINITION) {
      var o = t[a].name.value;
      var i = u(t[a]);
      if (!e.has(o)) {
        e.set(o, i);
        n.push(t[a]);
      } else if ("production" !== process.env.NODE_ENV && e.get(o) !== i) {
        console.warn("[WARNING: Duplicate Fragment] A fragment with name `" + o + "` already exists in this document.\nWhile fragment names may not be unique across your source, each name must be unique per document.");
      }
    } else {
      n.push(t[a]);
    }
  }
}

function gql() {
  var e = arguments;
  var n = new Map;
  var a = [];
  var o = [];
  var i = Array.isArray(arguments[0]) ? arguments[0][0] : arguments[0] || "";
  for (var u = 1; u < arguments.length; u++) {
    var c = e[u];
    if (c && c.definitions) {
      o.push.apply(o, c.definitions);
    } else {
      i += c;
    }
    i += e[0][u];
  }
  applyDefinitions(n, a, t(i).definitions);
  applyDefinitions(n, a, o);
  return t({
    kind: r.DOCUMENT,
    definitions: a
  });
}

function shouldSkip(e) {
  var r = e.kind;
  return "mutation" !== r && "query" !== r;
}

function cacheExchange(e) {
  var r = e.forward;
  var n = e.client;
  var t = e.dispatchDebug;
  var a = new Map;
  var i = Object.create(null);
  function mapTypeNames(e) {
    var r = makeOperation(e.kind, e);
    r.query = formatDocument(e.query);
    return r;
  }
  function isOperationCached(e) {
    var r = e.context.requestPolicy;
    return "query" === e.kind && "network-only" !== r && ("cache-only" === r || a.has(e.key));
  }
  return function(e) {
    var u = b(e);
    var c = w((function(e) {
      var r = a.get(e.key);
      "production" !== process.env.NODE_ENV && t(o({}, {
        operation: e
      }, r ? {
        type: "cacheHit",
        message: "The result was successfully retried from the cache"
      } : {
        type: "cacheMiss",
        message: "The result could not be retrieved from the cache"
      }));
      var i = o({}, r, {
        operation: addMetadata(e, {
          cacheOutcome: r ? "hit" : "miss"
        })
      });
      if ("cache-and-network" === e.context.requestPolicy) {
        i.stale = !0;
        reexecuteOperation(n, e);
      }
      return i;
    }))(O((function(e) {
      return !shouldSkip(e) && isOperationCached(e);
    }))(u));
    var s = q((function(e) {
      var r = e.operation;
      if (!r) {
        return;
      }
      var o = collectTypesFromResponse(e.data).concat(r.context.additionalTypenames || []);
      if ("mutation" === e.operation.kind) {
        var u = new Set;
        "production" !== process.env.NODE_ENV && t({
          type: "cacheInvalidation",
          message: "The following typenames have been invalidated: " + o,
          operation: r,
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
          data: {
            typenames: o,
            response: e
          },
          source: "cacheExchange"
        });
        for (var c = 0; c < o.length; c++) {
<<<<<<< HEAD
          var u = o[c];
          var p = i.get(u);
          if (!p) {
            i.set(u, p = new Set);
          }
          for (var d of p.values()) {
            s.add(d);
          }
          p.clear();
        }
        for (var v of s.values()) {
          if (a.has(v)) {
            n = a.get(v).operation;
            a.delete(v);
            reexecuteOperation(r, n);
          }
        }
      } else if ("query" === n.kind && e.data) {
        a.set(n.key, e);
        for (var l = 0; l < o.length; l++) {
          var f = o[l];
          var h = i.get(f);
          if (!h) {
            i.set(f, h = new Set);
          }
          h.add(n.key);
        }
      }
    }))(e(k((e => "query" !== e.kind || "cache-only" !== e.context.requestPolicy))(m((e => addMetadata(e, {
      cacheOutcome: "miss"
    })))(g([ m(mapTypeNames)(k((e => !shouldSkip(e) && !isOperationCached(e)))(o)), k((e => shouldSkip(e)))(o) ])))));
    return g([ s, c ]);
  };
};

var reexecuteOperation = (e, r) => e.reexecuteOperation(makeOperation(r.kind, r, {
  requestPolicy: "network-only"
}));

var T = new Set;

var ssrExchange = (e = {}) => {
  var r = !!e.staleWhileRevalidate;
  var t = !!e.includeExtensions;
  var n = {};
  var i = [];
  var invalidate = e => {
    i.push(e.operation.key);
    if (1 === i.length) {
      Promise.resolve().then((() => {
        var e;
        while (e = i.shift()) {
          n[e] = null;
        }
      }));
    }
  };
  var ssr = ({client: i, forward: o}) => s => {
    var c = e && "boolean" == typeof e.isClient ? !!e.isClient : !i.suspense;
    var u = o(m(mapTypeNames)(k((e => "teardown" === e.kind || !n[e.key] || !!n[e.key].hasNext || "network-only" === e.context.requestPolicy))(s)));
    var p = m((e => {
      var o = ((e, r, t) => ({
        operation: e,
        data: r.data ? JSON.parse(r.data) : void 0,
        extensions: t && r.extensions ? JSON.parse(r.extensions) : void 0,
        error: r.error ? new a({
          networkError: r.error.networkError ? new Error(r.error.networkError) : void 0,
          graphQLErrors: r.error.graphQLErrors
        }) : void 0,
        stale: !1,
        hasNext: !!r.hasNext
      }))(e, n[e.key], t);
      if (r && !T.has(e.key)) {
        o.stale = !0;
        T.add(e.key);
        reexecuteOperation(i, e);
      }
      return {
        ...o,
        operation: addMetadata(e, {
          cacheOutcome: "hit"
        })
      };
    }))(k((e => "teardown" !== e.kind && !!n[e.key] && "network-only" !== e.context.requestPolicy))(s));
    if (!c) {
      u = x((e => {
        var {operation: r} = e;
        if ("mutation" !== r.kind) {
          var a = ((e, r) => {
            var t = {
              hasNext: e.hasNext
            };
            if (void 0 !== e.data) {
              t.data = JSON.stringify(e.data);
            }
            if (r && void 0 !== e.extensions) {
              t.extensions = JSON.stringify(e.extensions);
            }
            if (e.error) {
              t.error = {
                graphQLErrors: e.error.graphQLErrors.map((e => {
                  if (!e.path && !e.extensions) {
                    return e.message;
                  }
                  return {
                    message: e.message,
                    path: e.path,
                    extensions: e.extensions
                  };
                }))
              };
              if (e.error.networkError) {
                t.error.networkError = "" + e.error.networkError;
              }
            }
            return t;
          })(e, t);
          n[r.key] = a;
        }
      }))(u);
    } else {
      p = x(invalidate)(p);
    }
    return g([ u, p ]);
  };
  ssr.restoreData = e => {
    for (var r in e) {
      if (null !== n[r]) {
        n[r] = e[r];
      }
    }
  };
  ssr.extractData = () => {
    var e = {};
    for (var r in n) {
      if (null != n[r]) {
        e[r] = n[r];
=======
          var s = o[c];
          var f = i[s] || (i[s] = new Set);
          f.forEach((function(e) {
            u.add(e);
          }));
          f.clear();
        }
        u.forEach((function(e) {
          if (a.has(e)) {
            r = a.get(e).operation;
            a.delete(e);
            reexecuteOperation(n, r);
          }
        }));
      } else if ("query" === r.kind && e.data) {
        a.set(r.key, e);
        for (var p = 0; p < o.length; p++) {
          var l = o[p];
          (i[l] || (i[l] = new Set)).add(r.key);
        }
      }
    }))(r(O((function(e) {
      return "query" !== e.kind || "cache-only" !== e.context.requestPolicy;
    }))(w((function(e) {
      return addMetadata(e, {
        cacheOutcome: "miss"
      });
    }))(N([ w(mapTypeNames)(O((function(e) {
      return !shouldSkip(e) && !isOperationCached(e);
    }))(u)), O((function(e) {
      return shouldSkip(e);
    }))(u) ])))));
    return N([ c, s ]);
  };
}

function reexecuteOperation(e, r) {
  return e.reexecuteOperation(makeOperation(r.kind, r, o({}, r.context, {
    requestPolicy: "network-only"
  })));
}

var G = new Set;

function ssrExchange(e) {
  var r = !(!e || !e.staleWhileRevalidate);
  var n = !(!e || !e.includeExtensions);
  var t = {};
  var a = [];
  function invalidate(e) {
    a.push(e.operation.key);
    if (1 === a.length) {
      Promise.resolve().then((function() {
        var e;
        while (e = a.shift()) {
          t[e] = null;
        }
      }));
    }
  }
  var ssr = function(a) {
    var o = a.client;
    var i = a.forward;
    return function(a) {
      var u = e && "boolean" == typeof e.isClient ? !!e.isClient : !o.suspense;
      var s = b(a);
      var f = i(O((function(e) {
        return !t[e.key] || !!t[e.key].hasNext;
      }))(s));
      var p = w((function(e) {
        var a = function deserializeResult(e, r, n) {
          return {
            operation: e,
            data: r.data ? JSON.parse(r.data) : void 0,
            extensions: n && r.extensions ? JSON.parse(r.extensions) : void 0,
            error: r.error ? new c({
              networkError: r.error.networkError ? new Error(r.error.networkError) : void 0,
              graphQLErrors: r.error.graphQLErrors
            }) : void 0,
            hasNext: r.hasNext
          };
        }(e, t[e.key], n);
        if (r && !G.has(e.key)) {
          a.stale = !0;
          G.add(e.key);
          reexecuteOperation(o, e);
        }
        return a;
      }))(O((function(e) {
        return !!t[e.key];
      }))(s));
      if (!u) {
        f = q((function(e) {
          var r = e.operation;
          if ("mutation" !== r.kind) {
            var a = function serializeResult(e, r) {
              var n = e.hasNext;
              var t = e.data;
              var a = e.extensions;
              var o = e.error;
              var i = {};
              if (void 0 !== t) {
                i.data = JSON.stringify(t);
              }
              if (r && void 0 !== a) {
                i.extensions = JSON.stringify(a);
              }
              if (n) {
                i.hasNext = !0;
              }
              if (o) {
                i.error = {
                  graphQLErrors: o.graphQLErrors.map((function(e) {
                    if (!e.path && !e.extensions) {
                      return e.message;
                    }
                    return {
                      message: e.message,
                      path: e.path,
                      extensions: e.extensions
                    };
                  }))
                };
                if (o.networkError) {
                  i.error.networkError = "" + o.networkError;
                }
              }
              return i;
            }(e, n);
            t[r.key] = a;
          }
        }))(f);
      } else {
        p = q(invalidate)(p);
      }
      return N([ f, p ]);
    };
  };
  ssr.restoreData = function(e) {
    for (var r in e) {
      if (null !== t[r]) {
        t[r] = e[r];
      }
    }
  };
  ssr.extractData = function() {
    var e = {};
    for (var r in t) {
      if (null != t[r]) {
        e[r] = t[r];
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
      }
    }
    return e;
  };
  if (e && e.initialState) {
    ssr.restoreData(e.initialState);
  }
  return ssr;
<<<<<<< HEAD
};

var subscriptionExchange = ({forwardSubscription: e, enableAllOperations: r, isSubscriptionOperation: t}) => ({client: a, forward: i}) => {
  var u = t || (e => "subscription" === e.kind || !!r && ("query" === e.kind || "mutation" === e.kind));
  return r => {
    var t = w((t => {
      var {key: i} = t;
      var u = k((e => "teardown" === e.kind && e.key === i))(r);
      return O(u)((r => {
        var t = e(o(r), r);
        return E((e => {
          var i = !1;
          var o;
          var u;
          function nextResult(t) {
            e.next(u = u ? c(u, t) : n(r, t));
          }
          Promise.resolve().then((() => {
            if (i) {
              return;
            }
            o = t.subscribe({
              next: nextResult,
              error(t) {
                if (Array.isArray(t)) {
                  nextResult({
                    errors: t
                  });
                } else {
                  e.next(s(r, t));
                }
                e.complete();
              },
              complete() {
                if (!i) {
                  i = !0;
                  if ("subscription" === r.kind) {
                    a.reexecuteOperation(makeOperation("teardown", r, r.context));
                  }
                  if (u && u.hasNext) {
                    nextResult({
                      hasNext: !1
                    });
                  }
                  e.complete();
                }
              }
            });
          }));
          return () => {
            i = !0;
            if (o) {
              o.unsubscribe();
            }
          };
        }));
      })(t));
    }))(k((e => "teardown" !== e.kind && u(e)))(r));
    var p = i(k((e => "teardown" === e.kind || !u(e)))(r));
    return g([ t, p ]);
  };
};

var debugExchange = ({forward: e}) => {
  if ("production" === process.env.NODE_ENV) {
    return r => e(r);
  } else {
    return r => x((e => console.debug("[Exchange debug]: Completed operation: ", e)))(e(x((e => console.debug("[Exchange debug]: Incoming operation: ", e)))(r)));
  }
};

var fetchExchange = ({forward: e, dispatchDebug: r}) => t => {
  var n = w((e => {
    var n = o(e);
    var a = u(e, n);
    var i = p(e, n);
    "production" !== process.env.NODE_ENV && r({
      type: "fetchRequest",
      message: "A fetch request is being executed.",
      operation: e,
      data: {
        url: a,
        fetchOptions: i
      },
      source: "fetchExchange"
    });
    var s = O(k((r => "teardown" === r.kind && r.key === e.key))(t))(d(e, a, i));
    if ("production" !== process.env.NODE_ENV) {
      return b((t => {
        var n = !t.data ? t.error : void 0;
        "production" !== process.env.NODE_ENV && r({
          type: n ? "fetchError" : "fetchSuccess",
          message: `A ${n ? "failed" : "successful"} fetch response has been returned.`,
          operation: e,
          data: {
            url: a,
            fetchOptions: i,
            value: n || t
          },
          source: "fetchExchange"
        });
      }))(s);
    }
    return s;
  }))(k((e => "teardown" !== e.kind && ("subscription" !== e.kind || !!e.context.fetchSubscriptions)))(t));
  var a = e(k((e => "teardown" === e.kind || "subscription" === e.kind && !e.context.fetchSubscriptions))(t));
  return g([ n, a ]);
};

var composeExchanges = e => ({client: r, forward: t, dispatchDebug: n}) => e.reduceRight(((e, t) => {
  var a = !1;
  return t({
    client: r,
    forward(r) {
      if ("production" !== process.env.NODE_ENV) {
        if (a) {
          throw new Error("forward() must only be called once in each Exchange.");
        }
        a = !0;
      }
      return N(e(N(r)));
    },
    dispatchDebug(e) {
      "production" !== process.env.NODE_ENV && n({
        timestamp: Date.now(),
        source: t.name,
        ...e
      });
    }
  });
}), t);

var mapExchange = ({onOperation: e, onResult: r, onError: t}) => ({forward: n}) => a => w((e => {
  if (t && e.error) {
    t(e.error, e.operation);
  }
  var n = r && r(e) || e;
  return "then" in n ? q(n) : _(n);
}))(n(w((r => {
  var t = e && e(r) || r;
  return "then" in t ? q(t) : _(t);
}))(a)));

var fallbackExchange = ({dispatchDebug: e}) => r => {
  if ("production" !== process.env.NODE_ENV) {
    r = x((r => {
      if ("teardown" !== r.kind && "production" !== process.env.NODE_ENV) {
        var t = `No exchange has handled operations of kind "${r.kind}". Check whether you've added an exchange responsible for these operations.`;
        "production" !== process.env.NODE_ENV && e({
          type: "fallbackCatch",
          message: t,
          operation: r,
          source: "fallbackExchange"
        });
        console.warn(t);
      }
    }))(r);
  }
  return k((e => !1))(r);
};

var C = function Client(e) {
  if ("production" !== process.env.NODE_ENV && !e.url) {
    throw new Error("You are creating an urql-client without a url.");
  }
  var r = 0;
  var t = new Map;
  var n = new Map;
  var a = new Set;
  var i = [];
  var o = {
    url: e.url,
    fetchSubscriptions: e.fetchSubscriptions,
    fetchOptions: e.fetchOptions,
    fetch: e.fetch,
    preferGetMethod: e.preferGetMethod,
    requestPolicy: e.requestPolicy || "cache-first"
  };
  var s = D();
  function nextOperation(e) {
    if ("mutation" === e.kind || "teardown" === e.kind || !a.has(e.key)) {
      if ("teardown" === e.kind) {
        a.delete(e.key);
      } else if ("mutation" !== e.kind) {
        a.add(e.key);
      }
      s.next(e);
    }
  }
  var c = !1;
  function dispatchOperation(e) {
    if (e) {
      nextOperation(e);
    }
    if (!c) {
      c = !0;
      while (c && (e = i.shift())) {
        nextOperation(e);
      }
      c = !1;
    }
  }
  var makeResultSource = e => {
    var r = O(k((r => "teardown" === r.kind && r.key === e.key))(s.source))(k((r => r.operation.kind === e.kind && r.operation.key === e.key && (!r.operation.context._instance || r.operation.context._instance === e.context._instance)))(E));
    if ("query" !== e.kind) {
      r = A((e => !!e.hasNext), !0)(r);
    } else {
      r = R((r => {
        var t = _(r);
        return r.stale || r.hasNext ? t : g([ t, m((() => {
          r.stale = !0;
          return r;
        }))(h(1)(k((r => r.key === e.key))(s.source))) ]);
      }))(r);
    }
    if ("mutation" !== e.kind) {
      r = M((() => {
        a.delete(e.key);
        t.delete(e.key);
        n.delete(e.key);
        c = !1;
        for (var r = i.length - 1; r >= 0; r--) {
          if (i[r].key === e.key) {
            i.splice(r, 1);
          }
        }
        nextOperation(makeOperation("teardown", e, e.context));
      }))(b((r => {
        if (r.stale) {
          if (!r.hasNext) {
            a.delete(e.key);
          } else {
            for (var n = 0; n < i.length; n++) {
              var o = i[n];
              if (o.key === r.operation.key) {
                a.delete(o.key);
                break;
              }
            }
          }
        } else if (!r.hasNext) {
          a.delete(e.key);
        }
        t.set(e.key, r);
      }))(r));
    } else {
      r = P((() => {
        nextOperation(e);
      }))(r);
    }
    return N(r);
  };
  var u = this instanceof Client ? this : Object.create(Client.prototype);
  var p = Object.assign(u, {
    suspense: !!e.suspense,
    operations$: s.source,
    reexecuteOperation(e) {
      if ("teardown" === e.kind) {
        dispatchOperation(e);
      } else if ("mutation" === e.kind) {
        i.push(e);
        Promise.resolve().then(dispatchOperation);
      } else if (n.has(e.key)) {
        var r = !1;
        for (var t = 0; t < i.length; t++) {
          if (i[t].key === e.key) {
            i[t] = e;
            r = !0;
          }
        }
        if (!(r || a.has(e.key) && "network-only" !== e.context.requestPolicy)) {
          i.push(e);
          Promise.resolve().then(dispatchOperation);
        } else {
          a.delete(e.key);
=======
}

function subscriptionExchange(e) {
  var r = e.forwardSubscription;
  var t = e.enableAllOperations;
  return function(e) {
    var a = e.client;
    var i = e.forward;
    function isSubscriptionOperation(e) {
      var r = e.kind;
      return "subscription" === r || !!t && ("query" === r || "mutation" === r);
    }
    return function(e) {
      var t = b(e);
      var u = D((function(e) {
        var i = e.key;
        var u = O((function(e) {
          return "teardown" === e.kind && e.key === i;
        }))(t);
        return _(u)(function createSubscriptionSource(e) {
          var t = r({
            key: e.key.toString(36),
            query: n(e.query),
            variables: e.variables,
            context: o({}, e.context)
          });
          return S((function(r) {
            var n = r.next;
            var o = r.complete;
            var i = !1;
            var u;
            Promise.resolve().then((function() {
              if (i) {
                return;
              }
              u = t.subscribe({
                next: function(r) {
                  return n(s(e, r));
                },
                error: function(r) {
                  return n(p(e, r));
                },
                complete: function() {
                  if (!i) {
                    i = !0;
                    if ("subscription" === e.kind) {
                      a.reexecuteOperation(makeOperation("teardown", e, e.context));
                    }
                    o();
                  }
                }
              });
            }));
            return function() {
              i = !0;
              if (u) {
                u.unsubscribe();
              }
            };
          }));
        }(e));
      }))(O(isSubscriptionOperation)(t));
      var c = i(O((function(e) {
        return !isSubscriptionOperation(e);
      }))(t));
      return N([ u, c ]);
    };
  };
}

function debugExchange(e) {
  var r = e.forward;
  if ("production" === process.env.NODE_ENV) {
    return function(e) {
      return r(e);
    };
  } else {
    return function(e) {
      return q((function(e) {
        return console.log("[Exchange debug]: Completed operation: ", e);
      }))(r(q((function(e) {
        return console.log("[Exchange debug]: Incoming operation: ", e);
      }))(e)));
    };
  }
}

function dedupExchange(e) {
  var r = e.forward;
  var n = e.dispatchDebug;
  var t = new Set;
  function filterIncomingOperation(e) {
    var r = e.key;
    var a = e.kind;
    if ("teardown" === a) {
      t.delete(r);
      return !0;
    }
    if ("query" !== a && "subscription" !== a) {
      return !0;
    }
    var o = t.has(r);
    t.add(r);
    if (o) {
      "production" !== process.env.NODE_ENV && n({
        type: "dedup",
        message: "An operation has been deduped.",
        operation: e,
        source: "dedupExchange"
      });
    }
    return !o;
  }
  function afterOperationResult(e) {
    if (!e.hasNext) {
      t.delete(e.operation.key);
    }
  }
  return function(e) {
    var n = O(filterIncomingOperation)(e);
    return q(afterOperationResult)(r(n));
  };
}

function fetchExchange(e) {
  var r = e.forward;
  var n = e.dispatchDebug;
  return function(e) {
    var t = b(e);
    var a = D((function(e) {
      var r = e.key;
      var a = O((function(e) {
        return "teardown" === e.kind && e.key === r;
      }))(t);
      var o = l(e);
      var i = d(e, o);
      var u = v(e, o);
      "production" !== process.env.NODE_ENV && n({
        type: "fetchRequest",
        message: "A fetch request is being executed.",
        operation: e,
        data: {
          url: i,
          fetchOptions: u
        },
        source: "fetchExchange"
      });
      return R((function(r) {
        var t = !r.data ? r.error : void 0;
        "production" !== process.env.NODE_ENV && n({
          type: t ? "fetchError" : "fetchSuccess",
          message: "A " + (t ? "failed" : "successful") + " fetch response has been returned.",
          operation: e,
          data: {
            url: i,
            fetchOptions: u,
            value: t || r
          },
          source: "fetchExchange"
        });
      }))(_(a)(y(e, i, u)));
    }))(O((function(e) {
      return "query" === e.kind || "mutation" === e.kind;
    }))(t));
    var o = r(O((function(e) {
      return "query" !== e.kind && "mutation" !== e.kind;
    }))(t));
    return N([ a, o ]);
  };
}

function fallbackExchange(e) {
  var r = e.dispatchDebug;
  return function(e) {
    return O((function() {
      return !1;
    }))(q((function(e) {
      if ("teardown" !== e.kind && "production" !== process.env.NODE_ENV) {
        var n = 'No exchange has handled operations of kind "' + e.kind + "\". Check whether you've added an exchange responsible for these operations.";
        "production" !== process.env.NODE_ENV && r({
          type: "fallbackCatch",
          message: n,
          operation: e,
          source: "fallbackExchange"
        });
        console.warn(n);
      }
    }))(e));
  };
}

var L = fallbackExchange({
  dispatchDebug: noop
});

function composeExchanges(e) {
  return function(r) {
    var n = r.client;
    var t = r.dispatchDebug;
    return e.reduceRight((function(e, r) {
      return r({
        client: n,
        forward: e,
        dispatchDebug: function dispatchDebug$1(e) {
          "production" !== process.env.NODE_ENV && t(o({}, {
            timestamp: Date.now(),
            source: r.name
          }, e));
        }
      });
    }), r.forward);
  };
}

function errorExchange(e) {
  var r = e.onError;
  return function(e) {
    var n = e.forward;
    return function(e) {
      return q((function(e) {
        var n = e.error;
        if (n) {
          r(n, e.operation);
        }
      }))(n(e));
    };
  };
}

var J = [ dedupExchange, cacheExchange, fetchExchange ];

var W = function Client(e) {
  if ("production" !== process.env.NODE_ENV && !e.url) {
    throw new Error("You are creating an urql-client without a url.");
  }
  var r = new Map;
  var n = new Map;
  var t = [];
  var a = T();
  var i = a.source;
  var u = a.next;
  var c = !1;
  function dispatchOperation(e) {
    c = !0;
    if (e) {
      u(e);
    }
    while (e = t.shift()) {
      u(e);
    }
    c = !1;
  }
  function makeResultSource(e) {
    var a = O((function(r) {
      return r.operation.kind === e.kind && r.operation.key === e.key;
    }))(y);
    if (f.maskTypename) {
      a = w((function(e) {
        return o({}, e, {
          data: maskTypename(e.data)
        });
      }))(a);
    }
    if ("mutation" === e.kind) {
      return E(1)(A((function() {
        return dispatchOperation(e);
      }))(a));
    }
    return b(M((function() {
      r.delete(e.key);
      n.delete(e.key);
      for (var a = t.length - 1; a >= 0; a--) {
        if (t[a].key === e.key) {
          t.splice(a, 1);
        }
      }
      dispatchOperation(makeOperation("teardown", e, e.context));
    }))(R((function(n) {
      r.set(e.key, n);
    }))(I((function(r) {
      if ("query" !== e.kind || r.stale) {
        return F(r);
      }
      return N([ F(r), w((function() {
        return o({}, r, {
          stale: !0
        });
      }))(E(1)(O((function(r) {
        return "query" === r.kind && r.key === e.key && "cache-only" !== r.context.requestPolicy;
      }))(i))) ]);
    }))(_(O((function(r) {
      return "teardown" === r.kind && r.key === e.key;
    }))(i))(a)))));
  }
  var s = this instanceof Client ? this : Object.create(Client.prototype);
  var f = o(s, {
    url: e.url,
    fetchOptions: e.fetchOptions,
    fetch: e.fetch,
    suspense: !!e.suspense,
    requestPolicy: e.requestPolicy || "cache-first",
    preferGetMethod: !!e.preferGetMethod,
    maskTypename: !!e.maskTypename,
    operations$: i,
    reexecuteOperation: function reexecuteOperation(e) {
      if ("mutation" === e.kind || n.has(e.key)) {
        t.push(e);
        if (!c) {
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
          Promise.resolve().then(dispatchOperation);
        }
      }
    },
<<<<<<< HEAD
    createRequestOperation(e, t, n) {
      if (!n) {
        n = {};
      }
      var a;
      if ("production" !== process.env.NODE_ENV && "teardown" !== e && (a = v(t.query)) !== e) {
        throw new Error(`Expected operation of type "${e}" but found "${a}"`);
      }
      return makeOperation(e, t, {
        _instance: "mutation" === e ? r = r + 1 | 0 : void 0,
        ...o,
        ...n,
        requestPolicy: n.requestPolicy || o.requestPolicy,
        suspense: n.suspense || !1 !== n.suspense && p.suspense
      });
    },
    executeRequestOperation(e) {
      if ("mutation" === e.kind) {
        return withPromise(makeResultSource(e));
      }
      return withPromise(S((() => {
        var r = n.get(e.key);
        if (!r) {
          n.set(e.key, r = makeResultSource(e));
        }
        r = P((() => {
          dispatchOperation(e);
        }))(r);
        var a = t.get(e.key);
        if ("query" === e.kind && a && (a.stale || a.hasNext)) {
          return R(_)(g([ r, k((r => r === t.get(e.key)))(_(a)) ]));
        } else {
          return r;
        }
      })));
    },
    executeQuery(e, r) {
      var t = p.createRequestOperation("query", e, r);
      return p.executeRequestOperation(t);
    },
    executeSubscription(e, r) {
      var t = p.createRequestOperation("subscription", e, r);
      return p.executeRequestOperation(t);
    },
    executeMutation(e, r) {
      var t = p.createRequestOperation("mutation", e, r);
      return p.executeRequestOperation(t);
    },
    readQuery(e, r, t) {
      var n = null;
      y((e => {
        n = e;
      }))(p.query(e, r, t)).unsubscribe();
      return n;
    },
    query: (e, r, t) => p.executeQuery(l(e, r), t),
    subscription: (e, r, t) => p.executeSubscription(l(e, r), t),
    mutation: (e, r, t) => p.executeMutation(l(e, r), t)
  });
  var d = noop;
  if ("production" !== process.env.NODE_ENV) {
    var {next: f, source: x} = D();
    p.subscribeToDebugTarget = e => y(e)(x);
    d = f;
  }
  var w = composeExchanges(e.exchanges);
  var E = N(w({
    client: p,
    dispatchDebug: d,
    forward: fallbackExchange({
      dispatchDebug: d
    })
  })(s.source));
  V(E);
  return p;
};

var Q = C;

export { C as Client, a as CombinedError, cacheExchange, composeExchanges, Q as createClient, l as createRequest, debugExchange, mapExchange as errorExchange, fetchExchange, formatDocument, gql, s as makeErrorResult, makeOperation, n as makeResult, mapExchange, c as mergeResultPatch, ssrExchange, t as stringifyDocument, subscriptionExchange };
=======
    createOperationContext: function createOperationContext(e) {
      if (!e) {
        e = {};
      }
      return o({}, {
        url: f.url,
        fetchOptions: f.fetchOptions,
        fetch: f.fetch,
        preferGetMethod: f.preferGetMethod
      }, e, {
        suspense: e.suspense || !1 !== e.suspense && f.suspense,
        requestPolicy: e.requestPolicy || f.requestPolicy
      });
    },
    createRequestOperation: function createRequestOperation(e, r, n) {
      var t = k(r.query);
      if ("production" !== process.env.NODE_ENV && "teardown" !== e && t !== e) {
        throw new Error('Expected operation of type "' + e + '" but found "' + t + '"');
      }
      return makeOperation(e, r, f.createOperationContext(n));
    },
    executeRequestOperation: function executeRequestOperation(e) {
      if ("mutation" === e.kind) {
        return makeResultSource(e);
      }
      return S((function(t) {
        var a = n.get(e.key);
        if (!a) {
          n.set(e.key, a = makeResultSource(e));
        }
        var i = "cache-and-network" === e.context.requestPolicy || "network-only" === e.context.requestPolicy;
        return P(t.next)(M(t.complete)(A((function() {
          var n = r.get(e.key);
          if ("subscription" === e.kind) {
            return dispatchOperation(e);
          } else if (i) {
            dispatchOperation(e);
          }
          if (null != n && n === r.get(e.key)) {
            t.next(i ? o({}, n, {
              stale: !0
            }) : n);
          } else if (!i) {
            dispatchOperation(e);
          }
        }))(a))).unsubscribe;
      }));
    },
    executeQuery: function executeQuery(e, r) {
      var n = f.createRequestOperation("query", e, r);
      return f.executeRequestOperation(n);
    },
    executeSubscription: function executeSubscription(e, r) {
      var n = f.createRequestOperation("subscription", e, r);
      return f.executeRequestOperation(n);
    },
    executeMutation: function executeMutation(e, r) {
      var n = f.createRequestOperation("mutation", e, r);
      return f.executeRequestOperation(n);
    },
    query: function query(e, r, n) {
      if (!n || "boolean" != typeof n.suspense) {
        n = o({}, n, {
          suspense: !1
        });
      }
      return withPromise(f.executeQuery(g(e, r), n));
    },
    readQuery: function readQuery(e, r, n) {
      var t = null;
      P((function(e) {
        t = e;
      }))(f.query(e, r, n)).unsubscribe();
      return t;
    },
    subscription: function subscription(e, r, n) {
      return f.executeSubscription(g(e, r), n);
    },
    mutation: function mutation(e, r, n) {
      return withPromise(f.executeMutation(g(e, r), n));
    }
  });
  var p = noop;
  if ("production" !== process.env.NODE_ENV) {
    var l = T();
    var d = l.next;
    var h = l.source;
    f.subscribeToDebugTarget = function(e) {
      return P(e)(h);
    };
    p = d;
  }
  var v = composeExchanges(void 0 !== e.exchanges ? e.exchanges : J);
  var y = b(v({
    client: f,
    dispatchDebug: p,
    forward: fallbackExchange({
      dispatchDebug: p
    })
  })(i));
  V(y);
  return f;
};

var z = W;

export { W as Client, cacheExchange, composeExchanges, z as createClient, debugExchange, dedupExchange, J as defaultExchanges, errorExchange, L as fallbackExchangeIO, fetchExchange, formatDocument, gql, makeOperation, maskTypename, ssrExchange, subscriptionExchange };
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
//# sourceMappingURL=urql-core.mjs.map
