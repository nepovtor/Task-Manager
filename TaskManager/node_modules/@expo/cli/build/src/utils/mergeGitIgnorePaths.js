"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
<<<<<<< HEAD
    createGeneratedHeaderComment: function() {
        return createGeneratedHeaderComment;
    },
    createGitIgnoreHash: function() {
        return createGitIgnoreHash;
    },
    generatedFooterComment: function() {
        return generatedFooterComment;
    },
    getSanitizedGitIgnoreLines: function() {
        return getSanitizedGitIgnoreLines;
    },
    mergeGitIgnoreContents: function() {
        return mergeGitIgnoreContents;
    },
    mergeGitIgnorePaths: function() {
        return mergeGitIgnorePaths;
    },
    removeFromGitIgnore: function() {
        return removeFromGitIgnore;
    },
    removeGeneratedGitIgnoreContents: function() {
        return removeGeneratedGitIgnoreContents;
    },
    upsertGitIgnoreContents: function() {
        return upsertGitIgnoreContents;
    }
});
function _crypto() {
    const data = /*#__PURE__*/ _interop_require_default(require("crypto"));
=======
    generatedFooterComment: ()=>generatedFooterComment,
    mergeGitIgnorePaths: ()=>mergeGitIgnorePaths,
    removeGeneratedGitIgnoreContents: ()=>removeGeneratedGitIgnoreContents,
    mergeGitIgnoreContents: ()=>mergeGitIgnoreContents,
    upsertGitIgnoreContents: ()=>upsertGitIgnoreContents,
    createGeneratedHeaderComment: ()=>createGeneratedHeaderComment,
    getSanitizedGitIgnoreLines: ()=>getSanitizedGitIgnoreLines,
    createGitIgnoreHash: ()=>createGitIgnoreHash,
    removeFromGitIgnore: ()=>removeFromGitIgnore
});
function _crypto() {
    const data = /*#__PURE__*/ _interopRequireDefault(require("crypto"));
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    _crypto = function() {
        return data;
    };
    return data;
}
function _fs() {
<<<<<<< HEAD
    const data = /*#__PURE__*/ _interop_require_default(require("fs"));
=======
    const data = /*#__PURE__*/ _interopRequireDefault(require("fs"));
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    _fs = function() {
        return data;
    };
    return data;
}
const _log = require("../log");
<<<<<<< HEAD
function _interop_require_default(obj) {
=======
function _interopRequireDefault(obj) {
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const generatedHeaderPrefix = `# @generated expo-cli`;
const generatedFooterComment = `# @end expo-cli`;
function mergeGitIgnorePaths(targetGitIgnorePath, sourceGitIgnorePath) {
    if (!_fs().default.existsSync(targetGitIgnorePath)) {
        // No gitignore in the project already, no need to merge anything into anything. I guess they
        // are not using git :O
        return null;
    }
    if (!_fs().default.existsSync(sourceGitIgnorePath)) {
        // Maybe we don't have a gitignore in the template project
        return null;
    }
    const targetGitIgnore = _fs().default.readFileSync(targetGitIgnorePath).toString();
    const sourceGitIgnore = _fs().default.readFileSync(sourceGitIgnorePath).toString();
    const merged = mergeGitIgnoreContents(targetGitIgnore, sourceGitIgnore);
    // Only rewrite the file if it was modified.
    if (merged.contents) {
        _fs().default.writeFileSync(targetGitIgnorePath, merged.contents);
    }
    return merged;
}
/**
 * Get line indexes for the generated section of a gitignore.
 *
 * @param gitIgnore
 */ function getGeneratedSectionIndexes(gitIgnore) {
<<<<<<< HEAD
    const contents = gitIgnore.split('\n');
=======
    const contents = gitIgnore.split("\n");
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    const start = contents.findIndex((line)=>line.startsWith(generatedHeaderPrefix));
    const end = contents.findIndex((line)=>line.startsWith(generatedFooterComment));
    return {
        contents,
        start,
        end
    };
}
function removeGeneratedGitIgnoreContents(gitIgnore) {
<<<<<<< HEAD
    const { contents, start, end } = getGeneratedSectionIndexes(gitIgnore);
=======
    const { contents , start , end  } = getGeneratedSectionIndexes(gitIgnore);
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    if (start > -1 && end > -1 && start < end) {
        contents.splice(start, end - start + 1);
        // TODO: We could in theory check that the contents we're removing match the hash used in the header,
        // this would ensure that we don't accidentally remove lines that someone added or removed from the generated section.
<<<<<<< HEAD
        return contents.join('\n');
=======
        return contents.join("\n");
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    }
    return null;
}
function mergeGitIgnoreContents(targetGitIgnore, sourceGitIgnore) {
    const header = createGeneratedHeaderComment(sourceGitIgnore);
    if (!targetGitIgnore.includes(header)) {
        // Ensure the old generated gitignore contents are removed.
        const sanitizedTarget = removeGeneratedGitIgnoreContents(targetGitIgnore);
        return {
            contents: [
<<<<<<< HEAD
                sanitizedTarget ?? targetGitIgnore,
=======
                sanitizedTarget != null ? sanitizedTarget : targetGitIgnore,
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
                header,
                `# The following patterns were generated by expo-cli`,
                ``,
                sourceGitIgnore,
<<<<<<< HEAD
                generatedFooterComment
            ].join('\n'),
=======
                generatedFooterComment, 
            ].join("\n"),
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
            didMerge: true,
            didClear: !!sanitizedTarget
        };
    }
    return {
        contents: targetGitIgnore,
        didClear: false,
        didMerge: false
    };
}
function upsertGitIgnoreContents(targetGitIgnorePath, contents) {
    const targetGitIgnore = _fs().default.readFileSync(targetGitIgnorePath, {
<<<<<<< HEAD
        encoding: 'utf-8',
        flag: 'a+'
    });
    if (targetGitIgnore.match(new RegExp(`^${contents}[\\n\\r\\s]*$`, 'm'))) {
=======
        encoding: "utf-8",
        flag: "a+"
    });
    if (targetGitIgnore.match(new RegExp(`^${contents}[\\n\\r\\s]*$`, "m"))) {
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
        return null;
    }
    // If there is an existing section, update it with the new content
    if (targetGitIgnore.includes(generatedHeaderPrefix)) {
        const indexes = getGeneratedSectionIndexes(targetGitIgnore);
<<<<<<< HEAD
        contents = `${indexes.contents.slice(indexes.start + 3, indexes.end).join('\n')}\n${contents}`;
=======
        contents = `${indexes.contents.slice(indexes.start + 3, indexes.end).join("\n")}\n${contents}`;
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    }
    const merged = mergeGitIgnoreContents(targetGitIgnore, contents);
    if (merged.contents) {
        _fs().default.writeFileSync(targetGitIgnorePath, merged.contents);
    }
    return merged;
}
function createGeneratedHeaderComment(gitIgnore) {
<<<<<<< HEAD
    const hashKey = createGitIgnoreHash(getSanitizedGitIgnoreLines(gitIgnore).join('\n'));
=======
    const hashKey = createGitIgnoreHash(getSanitizedGitIgnoreLines(gitIgnore).join("\n"));
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    return `${generatedHeaderPrefix} ${hashKey}`;
}
function getSanitizedGitIgnoreLines(gitIgnore) {
    // filter, trim, and sort the lines.
<<<<<<< HEAD
    return gitIgnore.split('\n').filter((v)=>{
        const line = v.trim();
        // Strip comments
        if (line.startsWith('#')) {
=======
    return gitIgnore.split("\n").filter((v)=>{
        const line = v.trim();
        // Strip comments
        if (line.startsWith("#")) {
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
            return false;
        }
        return !!line;
    }).sort();
}
function createGitIgnoreHash(gitIgnore) {
    // this doesn't need to be secure, the shorter the better.
<<<<<<< HEAD
    const hash = _crypto().default.createHash('sha1').update(gitIgnore).digest('hex');
=======
    const hash = _crypto().default.createHash("sha1").update(gitIgnore).digest("hex");
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    return `sync-${hash}`;
}
function removeFromGitIgnore(targetGitIgnorePath, contents) {
    try {
        if (!_fs().default.existsSync(targetGitIgnorePath)) {
            return;
        }
<<<<<<< HEAD
        let targetGitIgnore = _fs().default.readFileSync(targetGitIgnorePath, 'utf-8');
        if (!targetGitIgnore.includes(contents)) {
            return null;
        }
        targetGitIgnore = targetGitIgnore.replace(`${contents}\n`, '');
        const indexes = getGeneratedSectionIndexes(targetGitIgnore);
        if (indexes.start === indexes.end - 3) {
            targetGitIgnore = targetGitIgnore.replace(new RegExp(`^${generatedHeaderPrefix}((.|\n)*)${generatedFooterComment}$`, 'm'), '');
=======
        let targetGitIgnore = _fs().default.readFileSync(targetGitIgnorePath, "utf-8");
        if (!targetGitIgnore.includes(contents)) {
            return null;
        }
        targetGitIgnore = targetGitIgnore.replace(`${contents}\n`, "");
        const indexes = getGeneratedSectionIndexes(targetGitIgnore);
        if (indexes.start === indexes.end - 3) {
            targetGitIgnore = targetGitIgnore.replace(new RegExp(`^${generatedHeaderPrefix}((.|\n)*)${generatedFooterComment}$`, "m"), "");
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
        }
        return _fs().default.writeFileSync(targetGitIgnorePath, targetGitIgnore);
    } catch (error) {
        _log.Log.error(`Failed to read/write to .gitignore path: ${targetGitIgnorePath}`);
        throw error;
    }
}

//# sourceMappingURL=mergeGitIgnorePaths.js.map