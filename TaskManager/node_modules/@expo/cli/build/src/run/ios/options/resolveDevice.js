// import { resolveDestinationsAsync } from './appleDestinations';
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
<<<<<<< HEAD
    isSimulatorDevice: function() {
        return isSimulatorDevice;
    },
    resolveDeviceAsync: function() {
        return resolveDeviceAsync;
    }
});
const _promptDevice = require("./promptDevice");
const _log = /*#__PURE__*/ _interop_require_wildcard(require("../../../log"));
const _AppleDeviceManager = require("../../../start/platforms/ios/AppleDeviceManager");
const _promptAppleDevice = require("../../../start/platforms/ios/promptAppleDevice");
const _simctl = /*#__PURE__*/ _interop_require_wildcard(require("../../../start/platforms/ios/simctl"));
=======
    resolveDeviceAsync: ()=>resolveDeviceAsync,
    isSimulatorDevice: ()=>isSimulatorDevice
});
const _promptDevice = require("./promptDevice");
const _log = /*#__PURE__*/ _interopRequireWildcard(require("../../../log"));
const _appleDeviceManager = require("../../../start/platforms/ios/AppleDeviceManager");
const _promptAppleDevice = require("../../../start/platforms/ios/promptAppleDevice");
const _simctl = /*#__PURE__*/ _interopRequireWildcard(require("../../../start/platforms/ios/simctl"));
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
const _array = require("../../../utils/array");
const _errors = require("../../../utils/errors");
const _profile = require("../../../utils/profile");
const _hints = require("../../hints");
<<<<<<< HEAD
const _AppleDevice = /*#__PURE__*/ _interop_require_wildcard(require("../appleDevice/AppleDevice"));
=======
const _appleDevice = /*#__PURE__*/ _interopRequireWildcard(require("../appleDevice/AppleDevice"));
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
<<<<<<< HEAD
function _interop_require_wildcard(obj, nodeInterop) {
=======
function _interopRequireWildcard(obj, nodeInterop) {
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
<<<<<<< HEAD
    var newObj = {
        __proto__: null
    };
=======
    var newObj = {};
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
// type AnyDevice = SimControl.Device | AppleDevice.ConnectedDevice;
<<<<<<< HEAD
/** Get a list of devices (called destinations) that are connected to the host machine. Filter by `osType` if defined. */ async function getDevicesAsync({ osType }) {
    const devices = await (0, _promptAppleDevice.sortDefaultDeviceToBeginningAsync)((0, _array.uniqBy)((await Promise.all([
        _AppleDevice.getConnectedDevicesAsync(),
        await (0, _profile.profile)(_simctl.getDevicesAsync)()
=======
/** Get a list of devices (called destinations) that are connected to the host machine. Filter by `osType` if defined. */ async function getDevicesAsync({ osType  }) {
    const devices = await (0, _promptAppleDevice.sortDefaultDeviceToBeginningAsync)((0, _array.uniqBy)((await Promise.all([
        _appleDevice.getConnectedDevicesAsync(),
        await (0, _profile.profile)(_simctl.getDevicesAsync)(), 
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    ])).flat(), (item)=>item.udid), osType);
    // Sort devices to top of front of the list
    const physical = [];
    const simulators = devices.filter((device)=>{
<<<<<<< HEAD
        if ('isAvailable' in device) {
=======
        if ("isAvailable" in device) {
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
            return true;
        } else {
            physical.push(device);
            return false;
        }
    });
<<<<<<< HEAD
    const isPhone = (a)=>a.osType === 'iOS';
=======
    const isPhone = (a)=>a.osType === "iOS";
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    const sorted = [
        ...physical.sort((a, b)=>{
            const aPhone = isPhone(a);
            const bPhone = isPhone(b);
            if (aPhone && !bPhone) return -1;
            if (!aPhone && bPhone) return 1;
            return 0;
        }),
<<<<<<< HEAD
        ...simulators
=======
        ...simulators, 
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    ];
    // If osType is defined, then filter out ineligible simulators.
    // Only do this inside of the device selection so users who pass the entire device udid can attempt to select any simulator (even if it's invalid).
    return osType ? filterDevicesForOsType(sorted, osType) : sorted;
}
/** @returns a list of devices, filtered by the provided `osType`. */ function filterDevicesForOsType(devices, osType) {
    return devices.filter((device)=>{
<<<<<<< HEAD
        if (osType === 'iOS') {
            // Compatible devices for iOS builds
            return [
                'iOS',
                'macOS',
                'xrOS'
=======
        if (osType === "iOS") {
            // Compatible devices for iOS builds
            return [
                "iOS",
                "macOS",
                "xrOS"
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
            ].includes(device.osType);
        }
        return device.osType === osType;
    });
}
async function resolveDeviceAsync(device, buildProps) {
<<<<<<< HEAD
    await _AppleDeviceManager.AppleDeviceManager.assertSystemRequirementsAsync();
    if (!device) {
        /** Finds the first possible device and returns in a booted state. */ const manager = await _AppleDeviceManager.AppleDeviceManager.resolveAsync({
=======
    await _appleDeviceManager.AppleDeviceManager.assertSystemRequirementsAsync();
    if (!device) {
        /** Finds the first possible device and returns in a booted state. */ const manager = await _appleDeviceManager.AppleDeviceManager.resolveAsync({
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
            device: {
                osType: buildProps.osType
            }
        });
        _log.debug(`Resolved default device (name: ${manager.device.name}, udid: ${manager.device.udid}, osType: ${buildProps.osType})`);
        return manager.device;
    }
    const devices = await getDevicesAsync(buildProps);
    const resolved = device === true ? // @ts-expect-error
    await (0, _promptDevice.promptDeviceAsync)(devices) : findDeviceFromSearchValue(devices, device.toLowerCase());
    return ensureBootedAsync(resolved);
}
function isSimulatorDevice(device) {
<<<<<<< HEAD
    var _device_deviceType_startsWith, _device_deviceType;
    return !('deviceType' in device) || !!((_device_deviceType = device.deviceType) == null ? void 0 : (_device_deviceType_startsWith = _device_deviceType.startsWith) == null ? void 0 : _device_deviceType_startsWith.call(_device_deviceType, 'com.apple.CoreSimulator.SimDeviceType.'));
=======
    var ref;
    return !("deviceType" in device) || !!((ref = device.deviceType) == null ? void 0 : ref.startsWith == null ? void 0 : ref.startsWith("com.apple.CoreSimulator.SimDeviceType."));
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
}
/** @returns device matching the `searchValue` against name or UDID. */ function findDeviceFromSearchValue(devices, searchValue) {
    const device = devices.find((device)=>device.udid.toLowerCase() === searchValue || device.name.toLowerCase() === searchValue);
    if (!device) {
<<<<<<< HEAD
        throw new _errors.CommandError('BAD_ARGS', `No device UDID or name matching "${searchValue}"`);
=======
        throw new _errors.CommandError("BAD_ARGS", `No device UDID or name matching "${searchValue}"`);
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    }
    return device;
}
/** Ensures the device is booted if it's a simulator. */ async function ensureBootedAsync(device) {
    // --device with no props after
    (0, _hints.logDeviceArgument)(device.udid);
    if (isSimulatorDevice(device)) {
<<<<<<< HEAD
        return (0, _AppleDeviceManager.ensureSimulatorOpenAsync)({
=======
        return (0, _appleDeviceManager.ensureSimulatorOpenAsync)({
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
            udid: device.udid
        });
    }
    return device;
}

//# sourceMappingURL=resolveDevice.js.map