/**
 * Copyright (c) 2021 Expo, Inc.
 * Copyright (c) 2018 Drifty Co.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "UsbmuxdClient", {
    enumerable: true,
<<<<<<< HEAD
    get: function() {
        return UsbmuxdClient;
    }
});
function _plist() {
    const data = /*#__PURE__*/ _interop_require_default(require("@expo/plist"));
=======
    get: ()=>UsbmuxdClient
});
function _plist() {
    const data = /*#__PURE__*/ _interopRequireDefault(require("@expo/plist"));
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    _plist = function() {
        return data;
    };
    return data;
}
function _debug() {
<<<<<<< HEAD
    const data = /*#__PURE__*/ _interop_require_default(require("debug"));
=======
    const data = /*#__PURE__*/ _interopRequireDefault(require("debug"));
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    _debug = function() {
        return data;
    };
    return data;
}
function _net() {
    const data = require("net");
    _net = function() {
        return data;
    };
    return data;
}
<<<<<<< HEAD
const _ServiceClient = require("./ServiceClient");
const _errors = require("../../../../utils/errors");
const _plist1 = require("../../../../utils/plist");
const _UsbmuxProtocol = require("../protocol/UsbmuxProtocol");
function _interop_require_default(obj) {
=======
const _serviceClient = require("./ServiceClient");
const _errors = require("../../../../utils/errors");
const _plist1 = require("../../../../utils/plist");
const _usbmuxProtocol = require("../protocol/UsbmuxProtocol");
function _interopRequireDefault(obj) {
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
<<<<<<< HEAD
const debug = (0, _debug().default)('expo:apple-device:client:usbmuxd');
function isUsbmuxdConnectResponse(resp) {
    return resp.MessageType === 'Result' && resp.Number !== undefined;
=======
const debug = (0, _debug().default)("expo:apple-device:client:usbmuxd");
function isUsbmuxdConnectResponse(resp) {
    return resp.MessageType === "Result" && resp.Number !== undefined;
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
}
function isUsbmuxdDeviceResponse(resp) {
    return resp.DeviceList !== undefined;
}
function isUsbmuxdPairRecordResponse(resp) {
    return resp.PairRecordData !== undefined;
}
<<<<<<< HEAD
class UsbmuxdClient extends _ServiceClient.ServiceClient {
    constructor(socket){
        super(socket, new _UsbmuxProtocol.UsbmuxProtocolClient(socket)), this.socket = socket;
    }
    static connectUsbmuxdSocket() {
        debug('connectUsbmuxdSocket');
        if (process.platform === 'win32') {
            return (0, _net().connect)({
                port: 27015,
                host: 'localhost'
            });
        } else {
            return (0, _net().connect)({
                path: '/var/run/usbmuxd'
=======
class UsbmuxdClient extends _serviceClient.ServiceClient {
    constructor(socket){
        super(socket, new _usbmuxProtocol.UsbmuxProtocolClient(socket));
        this.socket = socket;
    }
    static connectUsbmuxdSocket() {
        debug("connectUsbmuxdSocket");
        if (process.platform === "win32") {
            return (0, _net().connect)({
                port: 27015,
                host: "localhost"
            });
        } else {
            return (0, _net().connect)({
                path: "/var/run/usbmuxd"
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
            });
        }
    }
    async connect(device, port) {
        debug(`connect: ${device.DeviceID} on port ${port}`);
        debug(`connect:device: %O`, device);
        const response = await this.protocolClient.sendMessage({
<<<<<<< HEAD
            messageType: 'Connect',
=======
            messageType: "Connect",
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
            extraFields: {
                DeviceID: device.DeviceID,
                PortNumber: htons(port)
            }
        });
        debug(`connect:device:response: %O`, response);
        if (isUsbmuxdConnectResponse(response) && response.Number === 0) {
            return this.protocolClient.socket;
        } else {
<<<<<<< HEAD
            throw new _ServiceClient.ResponseError(`There was an error connecting to the USB connected device (id: ${device.DeviceID}, port: ${port})`, response);
        }
    }
    async getDevices() {
        debug('getDevices');
        const resp = await this.protocolClient.sendMessage({
            messageType: 'ListDevices'
=======
            throw new _serviceClient.ResponseError(`There was an error connecting to the USB connected device (id: ${device.DeviceID}, port: ${port})`, response);
        }
    }
    async getDevices() {
        debug("getDevices");
        const resp = await this.protocolClient.sendMessage({
            messageType: "ListDevices"
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
        });
        if (isUsbmuxdDeviceResponse(resp)) {
            return resp.DeviceList;
        } else {
<<<<<<< HEAD
            throw new _ServiceClient.ResponseError('Invalid response from getDevices', resp);
        }
    }
    async getDevice(udid) {
        debug(`getDevice ${udid ? 'udid: ' + udid : ''}`);
        const devices = await this.getDevices();
        if (!devices.length) {
            throw new _errors.CommandError('APPLE_DEVICE_USBMUXD', 'No devices found');
=======
            throw new _serviceClient.ResponseError("Invalid response from getDevices", resp);
        }
    }
    async getDevice(udid) {
        debug(`getDevice ${udid ? "udid: " + udid : ""}`);
        const devices = await this.getDevices();
        if (!devices.length) {
            throw new _errors.CommandError("APPLE_DEVICE_USBMUXD", "No devices found");
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
        }
        if (!udid) {
            return devices[0];
        }
        for (const device of devices){
            if (device.Properties && device.Properties.SerialNumber === udid) {
                return device;
            }
        }
<<<<<<< HEAD
        throw new _errors.CommandError('APPLE_DEVICE_USBMUXD', `No device found (udid: ${udid})`);
=======
        throw new _errors.CommandError("APPLE_DEVICE_USBMUXD", `No device found (udid: ${udid})`);
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    }
    async readPairRecord(udid) {
        debug(`readPairRecord: ${udid}`);
        const resp = await this.protocolClient.sendMessage({
<<<<<<< HEAD
            messageType: 'ReadPairRecord',
=======
            messageType: "ReadPairRecord",
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
            extraFields: {
                PairRecordID: udid
            }
        });
        if (isUsbmuxdPairRecordResponse(resp)) {
            // the pair record can be created as a binary plist
<<<<<<< HEAD
            const BPLIST_MAGIC = Buffer.from('bplist00');
            if (BPLIST_MAGIC.compare(resp.PairRecordData, 0, 8) === 0) {
                debug('Binary plist pair record detected.');
                const pairRecords = (0, _plist1.parsePlistBuffer)(resp.PairRecordData);
                return Array.isArray(pairRecords) ? pairRecords[0] : pairRecords;
=======
            const BPLIST_MAGIC = Buffer.from("bplist00");
            if (BPLIST_MAGIC.compare(resp.PairRecordData, 0, 8) === 0) {
                debug("Binary plist pair record detected.");
                return (0, _plist1.parsePlistBuffer)(resp.PairRecordData)[0];
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
            } else {
                // TODO: use parsePlistBuffer
                return _plist().default.parse(resp.PairRecordData.toString()); // TODO: type guard
            }
        } else {
<<<<<<< HEAD
            throw new _ServiceClient.ResponseError(`There was an error reading pair record for device (udid: ${udid})`, resp);
=======
            throw new _serviceClient.ResponseError(`There was an error reading pair record for device (udid: ${udid})`, resp);
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
        }
    }
}
function htons(n) {
    return (n & 0xff) << 8 | n >> 8 & 0xff;
}

//# sourceMappingURL=UsbmuxdClient.js.map