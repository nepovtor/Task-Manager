"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
<<<<<<< HEAD
    formatDeviceChoice: function() {
        return formatDeviceChoice;
    },
    promptForDeviceAsync: function() {
        return promptForDeviceAsync;
    }
});
function _chalk() {
    const data = /*#__PURE__*/ _interop_require_default(require("chalk"));
=======
    promptForDeviceAsync: ()=>promptForDeviceAsync,
    formatDeviceChoice: ()=>formatDeviceChoice
});
function _chalk() {
    const data = /*#__PURE__*/ _interopRequireDefault(require("chalk"));
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    _chalk = function() {
        return data;
    };
    return data;
}
const _adb = require("./adb");
const _errors = require("../../../utils/errors");
const _prompts = require("../../../utils/prompts");
<<<<<<< HEAD
function _interop_require_default(obj) {
=======
function _interopRequireDefault(obj) {
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
async function promptForDeviceAsync(devices) {
    // TODO: provide an option to add or download more simulators
<<<<<<< HEAD
    const { value } = await (0, _prompts.promptAsync)({
        type: 'autocomplete',
        name: 'value',
        limit: 11,
        message: 'Select a device/emulator',
        choices: devices.map((item)=>formatDeviceChoice(item)),
        suggest: (0, _prompts.createSelectionFilter)()
    });
    const device = devices.find(({ name })=>name === value);
=======
    const { value  } = await (0, _prompts.promptAsync)({
        type: "autocomplete",
        name: "value",
        limit: 11,
        message: "Select a device/emulator",
        choices: devices.map((item)=>formatDeviceChoice(item)),
        suggest: (0, _prompts.createSelectionFilter)()
    });
    const device = devices.find(({ name  })=>name === value);
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    if ((device == null ? void 0 : device.isAuthorized) === false) {
        (0, _adb.logUnauthorized)(device);
        throw new _errors.AbortCommandError();
    }
    return device;
}
function formatDeviceChoice(device) {
    const symbol = getDeviceChoiceSymbol(device);
    const name = getDeviceChoiceName(device);
<<<<<<< HEAD
    const type = _chalk().default.dim(device.isAuthorized ? device.type : 'unauthorized');
=======
    const type = _chalk().default.dim(device.isAuthorized ? device.type : "unauthorized");
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    return {
        value: device.name,
        title: `${symbol}${name} (${type})`
    };
}
/** Get the styled symbol of the device, based on ADB connection type (usb vs network) */ function getDeviceChoiceSymbol(device) {
<<<<<<< HEAD
    if (device.type === 'device' && device.connectionType === 'Network') {
        return 'ðŸŒ ';
    }
    if (device.type === 'device') {
        return 'ðŸ”Œ ';
    }
    return '';
=======
    if (device.type === "device" && device.connectionType === "Network") {
        return "\uD83C\uDF10 ";
    }
    if (device.type === "device") {
        return "\uD83D\uDD0C ";
    }
    return "";
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
}
/** Get the styled name of the device, based on device state */ function getDeviceChoiceName(device) {
    // Use no style changes for a disconnected device that is available to be opened.
    if (!device.isBooted) {
        return device.name;
    }
    // A device that is connected and ready to be used should be bolded to match iOS.
    if (device.isAuthorized) {
        return _chalk().default.bold(device.name);
    }
    // Devices that are unauthorized and connected cannot be used, but they are connected so gray them out.
    return _chalk().default.bold(_chalk().default.gray(device.name));
}

//# sourceMappingURL=promptAndroidDevice.js.map