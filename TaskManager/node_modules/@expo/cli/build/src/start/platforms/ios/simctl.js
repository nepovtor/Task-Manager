"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
<<<<<<< HEAD
    bootAsync: function() {
        return bootAsync;
    },
    bootDeviceAsync: function() {
        return bootDeviceAsync;
    },
    getBootedSimulatorsAsync: function() {
        return getBootedSimulatorsAsync;
    },
    getContainerPathAsync: function() {
        return getContainerPathAsync;
    },
    getDevicesAsync: function() {
        return getDevicesAsync;
    },
    getInfoPlistValueAsync: function() {
        return getInfoPlistValueAsync;
    },
    installAsync: function() {
        return installAsync;
    },
    isDeviceBootedAsync: function() {
        return isDeviceBootedAsync;
    },
    isOSType: function() {
        return isOSType;
    },
    openAppIdAsync: function() {
        return openAppIdAsync;
    },
    openUrlAsync: function() {
        return openUrlAsync;
    },
    simctlAsync: function() {
        return simctlAsync;
    },
    uninstallAsync: function() {
        return uninstallAsync;
    }
});
function _spawnasync() {
    const data = /*#__PURE__*/ _interop_require_default(require("@expo/spawn-async"));
    _spawnasync = function() {
=======
    isOSType: ()=>isOSType,
    getContainerPathAsync: ()=>getContainerPathAsync,
    getInfoPlistValueAsync: ()=>getInfoPlistValueAsync,
    openUrlAsync: ()=>openUrlAsync,
    openAppIdAsync: ()=>openAppIdAsync,
    bootAsync: ()=>bootAsync,
    getBootedSimulatorsAsync: ()=>getBootedSimulatorsAsync,
    isDeviceBootedAsync: ()=>isDeviceBootedAsync,
    bootDeviceAsync: ()=>bootDeviceAsync,
    installAsync: ()=>installAsync,
    uninstallAsync: ()=>uninstallAsync,
    getDevicesAsync: ()=>getDevicesAsync,
    simctlAsync: ()=>simctlAsync
});
function _spawnAsync() {
    const data = /*#__PURE__*/ _interopRequireDefault(require("@expo/spawn-async"));
    _spawnAsync = function() {
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
        return data;
    };
    return data;
}
<<<<<<< HEAD
function _bplistcreator() {
    const data = /*#__PURE__*/ _interop_require_default(require("bplist-creator"));
    _bplistcreator = function() {
=======
function _bplistCreator() {
    const data = /*#__PURE__*/ _interopRequireDefault(require("bplist-creator"));
    _bplistCreator = function() {
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
        return data;
    };
    return data;
}
function _fs() {
<<<<<<< HEAD
    const data = /*#__PURE__*/ _interop_require_default(require("fs"));
=======
    const data = /*#__PURE__*/ _interopRequireDefault(require("fs"));
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    _fs = function() {
        return data;
    };
    return data;
}
function _os() {
<<<<<<< HEAD
    const data = /*#__PURE__*/ _interop_require_default(require("os"));
=======
    const data = /*#__PURE__*/ _interopRequireDefault(require("os"));
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    _os = function() {
        return data;
    };
    return data;
}
function _path() {
<<<<<<< HEAD
    const data = /*#__PURE__*/ _interop_require_default(require("path"));
=======
    const data = /*#__PURE__*/ _interopRequireDefault(require("path"));
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    _path = function() {
        return data;
    };
    return data;
}
const _xcrun = require("./xcrun");
<<<<<<< HEAD
const _log = /*#__PURE__*/ _interop_require_wildcard(require("../../../log"));
=======
const _log = /*#__PURE__*/ _interopRequireWildcard(require("../../../log"));
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
const _errors = require("../../../utils/errors");
const _fn = require("../../../utils/fn");
const _plist = require("../../../utils/plist");
const _profile = require("../../../utils/profile");
<<<<<<< HEAD
function _interop_require_default(obj) {
=======
function _interopRequireDefault(obj) {
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
<<<<<<< HEAD
function _interop_require_wildcard(obj, nodeInterop) {
=======
function _interopRequireWildcard(obj, nodeInterop) {
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
<<<<<<< HEAD
    var newObj = {
        __proto__: null
    };
=======
    var newObj = {};
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
<<<<<<< HEAD
const debug = require('debug')('expo:simctl');
function isOSType(value) {
    if (!value || typeof value !== 'string') return false;
    const knownTypes = [
        'iOS',
        'tvOS',
        'watchOS',
        'macOS'
    ];
    if (!knownTypes.includes(value)) {
        _log.warn(`Unknown OS type: ${value}. Expected one of: ${knownTypes.join(', ')}`);
    }
    return true;
}
async function getContainerPathAsync(device, { appId }) {
    try {
        const { stdout } = await simctlAsync([
            'get_app_container',
=======
const debug = require("debug")("expo:simctl");
function isOSType(value) {
    if (!value || typeof value !== "string") return false;
    const knownTypes = [
        "iOS",
        "tvOS",
        "watchOS",
        "macOS"
    ];
    if (!knownTypes.includes(value)) {
        _log.warn(`Unknown OS type: ${value}. Expected one of: ${knownTypes.join(", ")}`);
    }
    return true;
}
async function getContainerPathAsync(device, { appId  }) {
    try {
        const { stdout  } = await simctlAsync([
            "get_app_container",
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
            resolveId(device),
            appId
        ]);
        return stdout.trim();
    } catch (error) {
<<<<<<< HEAD
        var _error_stderr;
        if ((_error_stderr = error.stderr) == null ? void 0 : _error_stderr.match(/No such file or directory/)) {
=======
        var ref;
        if ((ref = error.stderr) == null ? void 0 : ref.match(/No such file or directory/)) {
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
            return null;
        }
        throw error;
    }
}
<<<<<<< HEAD
async function getInfoPlistValueAsync(device, { appId, key, containerPath }) {
    const ensuredContainerPath = containerPath ?? await getContainerPathAsync(device, {
=======
async function getInfoPlistValueAsync(device, { appId , key , containerPath  }) {
    const ensuredContainerPath = containerPath != null ? containerPath : await getContainerPathAsync(device, {
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
        appId
    });
    if (ensuredContainerPath) {
        try {
<<<<<<< HEAD
            const { output } = await (0, _spawnasync().default)('defaults', [
                'read',
                `${ensuredContainerPath}/Info`,
                key
            ], {
                stdio: 'pipe'
            });
            return output.join('\n').trim();
=======
            const { output  } = await (0, _spawnAsync().default)("defaults", [
                "read",
                `${ensuredContainerPath}/Info`,
                key
            ], {
                stdio: "pipe"
            });
            return output.join("\n").trim();
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
        } catch  {
            return null;
        }
    }
    return null;
}
<<<<<<< HEAD
/** Rewrite the simulator permissions to allow opening deep links without needing to prompt the user first. */ async function updateSimulatorLinkingPermissionsAsync(device, { url, appId }) {
    if (!device.udid || !appId) {
        debug('Skipping deep link permissions as missing properties could not be found:', {
=======
/** Rewrite the simulator permissions to allow opening deep links without needing to prompt the user first. */ async function updateSimulatorLinkingPermissionsAsync(device, { url , appId  }) {
    if (!device.udid || !appId) {
        debug("Skipping deep link permissions as missing properties could not be found:", {
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
            url,
            appId,
            udid: device.udid
        });
        return;
    }
<<<<<<< HEAD
    debug('Rewriting simulator permissions to support deep linking:', {
=======
    debug("Rewriting simulator permissions to support deep linking:", {
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
        url,
        appId,
        udid: device.udid
    });
    let scheme;
    try {
        // Attempt to extract the scheme from the URL.
        scheme = new URL(url).protocol.slice(0, -1);
    } catch (error) {
        debug(`Could not parse the URL scheme: ${error.message}`);
        return;
    }
    // Get the hard-coded path to the simulator's scheme approval plist file.
    const plistPath = _path().default.join(_os().default.homedir(), `Library/Developer/CoreSimulator/Devices`, device.udid, `data/Library/Preferences/com.apple.launchservices.schemeapproval.plist`);
    const plistData = _fs().default.existsSync(plistPath) ? await (0, _plist.parsePlistAsync)(plistPath) : // Can be tested by launching a new simulator or by deleting the file and relaunching the simulator.
    {};
<<<<<<< HEAD
    debug('Allowed links:', plistData);
    const key = `com.apple.CoreSimulator.CoreSimulatorBridge-->${scheme}`;
    // Replace any existing value for the scheme with the new appId.
    plistData[key] = appId;
    debug('Allowing deep link:', {
=======
    debug("Allowed links:", plistData);
    const key = `com.apple.CoreSimulator.CoreSimulatorBridge-->${scheme}`;
    // Replace any existing value for the scheme with the new appId.
    plistData[key] = appId;
    debug("Allowing deep link:", {
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
        key,
        appId
    });
    try {
<<<<<<< HEAD
        const data = (0, _bplistcreator().default)(plistData);
        // Write the updated plist back to disk
        await _fs().default.promises.writeFile(plistPath, data);
    } catch (error) {
        _log.warn(`Could not update simulator linking permissions: ${error.message}`);
=======
        const data = (0, _bplistCreator().default)(plistData);
        // Write the updated plist back to disk
        await _fs().default.promises.writeFile(plistPath, data);
    } catch (error1) {
        _log.warn(`Could not update simulator linking permissions: ${error1.message}`);
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    }
}
const updateSimulatorLinkingPermissionsAsyncMemo = (0, _fn.memoize)(updateSimulatorLinkingPermissionsAsync);
async function openUrlAsync(device, options) {
    if (options.appId) {
<<<<<<< HEAD
        await (0, _profile.profile)(updateSimulatorLinkingPermissionsAsyncMemo, 'updateSimulatorLinkingPermissionsAsync')({
=======
        await (0, _profile.profile)(updateSimulatorLinkingPermissionsAsyncMemo, "updateSimulatorLinkingPermissionsAsync")({
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
            udid: device.udid
        }, options);
    }
    try {
        // Skip logging since this is likely to fail.
        await simctlAsync([
<<<<<<< HEAD
            'openurl',
=======
            "openurl",
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
            resolveId(device),
            options.url
        ]);
    } catch (error) {
<<<<<<< HEAD
        var _error_stderr;
        if (!((_error_stderr = error.stderr) == null ? void 0 : _error_stderr.match(/Unable to lookup in current state: Shut/))) {
=======
        var ref;
        if (!((ref = error.stderr) == null ? void 0 : ref.match(/Unable to lookup in current state: Shut/))) {
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
            throw error;
        }
        // If the device was in a weird in-between state ("Shutting Down" or "Shutdown"), then attempt to reboot it and try again.
        // This can happen when quitting the Simulator app, and immediately pressing `i` to reopen the project.
        // First boot the simulator
        await bootDeviceAsync({
            udid: resolveId(device)
        });
        // Finally, try again...
        return await openUrlAsync(device, options);
    }
}
async function openAppIdAsync(device, options) {
    const results = await openAppIdInternalAsync(device, options);
    // Similar to 194, this is a conformance issue which indicates that the given device has no app that can handle our launch request.
    if (results.status === 4) {
<<<<<<< HEAD
        throw new _errors.CommandError('APP_NOT_INSTALLED', results.stderr);
=======
        throw new _errors.CommandError("APP_NOT_INSTALLED", results.stderr);
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    }
    return results;
}
async function openAppIdInternalAsync(device, options) {
    try {
        return await simctlAsync([
<<<<<<< HEAD
            'launch',
=======
            "launch",
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
            resolveId(device),
            options.appId
        ]);
    } catch (error) {
<<<<<<< HEAD
        if ('status' in error) {
=======
        if ("status" in error) {
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
            return error;
        }
        throw error;
    }
}
async function bootAsync(device) {
    await bootDeviceAsync(device);
    return isDeviceBootedAsync(device);
}
async function getBootedSimulatorsAsync() {
<<<<<<< HEAD
    const simulatorDeviceInfo = await getRuntimesAsync('devices');
    return Object.values(simulatorDeviceInfo.devices).flatMap((runtime)=>runtime.filter((device)=>device.state === 'Booted'));
=======
    const simulatorDeviceInfo = await getRuntimesAsync("devices");
    return Object.values(simulatorDeviceInfo.devices).flatMap((runtime)=>runtime.filter((device)=>device.state === "Booted"));
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
}
async function isDeviceBootedAsync(device) {
    // Simulators can be booted even if the app isn't running :(
    const devices = await getBootedSimulatorsAsync();
    if (device.udid) {
<<<<<<< HEAD
        return devices.find((bootedDevice)=>bootedDevice.udid === device.udid) ?? null;
    }
    return devices[0] ?? null;
=======
        var ref;
        return (ref = devices.find((bootedDevice)=>bootedDevice.udid === device.udid)) != null ? ref : null;
    }
    var ref1;
    return (ref1 = devices[0]) != null ? ref1 : null;
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
}
async function bootDeviceAsync(device) {
    try {
        // Skip logging since this is likely to fail.
        await simctlAsync([
<<<<<<< HEAD
            'boot',
            device.udid
        ]);
    } catch (error) {
        var _error_stderr;
        if (!((_error_stderr = error.stderr) == null ? void 0 : _error_stderr.match(/Unable to boot device in current state: Booted/))) {
=======
            "boot",
            device.udid
        ]);
    } catch (error) {
        var ref;
        if (!((ref = error.stderr) == null ? void 0 : ref.match(/Unable to boot device in current state: Booted/))) {
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
            throw error;
        }
    }
}
async function installAsync(device, options) {
    return simctlAsync([
<<<<<<< HEAD
        'install',
=======
        "install",
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
        resolveId(device),
        options.filePath
    ]);
}
async function uninstallAsync(device, options) {
    return simctlAsync([
<<<<<<< HEAD
        'uninstall',
=======
        "uninstall",
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
        resolveId(device),
        options.appId
    ]);
}
function parseSimControlJSONResults(input) {
    try {
        return JSON.parse(input);
    } catch (error) {
        // Nov 15, 2020: Observed this can happen when opening the simulator and the simulator prompts the user to update the xcode command line tools.
        // Unexpected token I in JSON at position 0
<<<<<<< HEAD
        if (error.message.includes('Unexpected token')) {
=======
        if (error.message.includes("Unexpected token")) {
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
            _log.error(`Apple's simctl returned malformed JSON:\n${input}`);
        }
        throw error;
    }
}
/** Get all runtime devices given a certain type. */ async function getRuntimesAsync(type, query) {
    const result = await simctlAsync([
<<<<<<< HEAD
        'list',
        type,
        '--json',
=======
        "list",
        type,
        "--json",
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
        query
    ]);
    const info = parseSimControlJSONResults(result.stdout);
    for (const runtime of Object.keys(info.devices)){
        // Given a string like 'com.apple.CoreSimulator.SimRuntime.tvOS-13-4'
<<<<<<< HEAD
        const runtimeSuffix = runtime.split('com.apple.CoreSimulator.SimRuntime.').pop();
        // Create an array [tvOS, 13, 4]
        const [osType, ...osVersionComponents] = runtimeSuffix.split('-');
        // Join the end components [13, 4] -> '13.4'
        const osVersion = osVersionComponents.join('.');
=======
        const runtimeSuffix = runtime.split("com.apple.CoreSimulator.SimRuntime.").pop();
        // Create an array [tvOS, 13, 4]
        const [osType, ...osVersionComponents] = runtimeSuffix.split("-");
        // Join the end components [13, 4] -> '13.4'
        const osVersion = osVersionComponents.join(".");
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
        const sims = info.devices[runtime];
        for (const device of sims){
            device.runtime = runtime;
            device.osVersion = osVersion;
            device.windowName = `${device.name} (${osVersion})`;
            device.osType = osType;
        }
    }
    return info;
}
async function getDevicesAsync() {
<<<<<<< HEAD
    const simulatorDeviceInfo = await getRuntimesAsync('devices');
    return Object.values(simulatorDeviceInfo.devices).flat();
}
async function simctlAsync(args, options) {
    try {
        return await (0, _xcrun.xcrunAsync)([
            'simctl',
            ...args
        ], options);
    } catch (error) {
        if ((0, _xcrun.isSpawnResultError)(error)) {
        // TODO: Add more tips.
        // if (error.status === 115) {
        // }
        }
        throw error;
    }
}
function resolveId(device) {
    return device.udid ?? 'booted';
=======
    const simulatorDeviceInfo = await getRuntimesAsync("devices");
    return Object.values(simulatorDeviceInfo.devices).flat();
}
async function simctlAsync(args, options) {
    return (0, _xcrun.xcrunAsync)([
        "simctl",
        ...args
    ], options);
}
function resolveId(device) {
    var _udid;
    return (_udid = device.udid) != null ? _udid : "booted";
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
}

//# sourceMappingURL=simctl.js.map