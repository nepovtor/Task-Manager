"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "ADBServer", {
    enumerable: true,
<<<<<<< HEAD
    get: function() {
        return ADBServer;
    }
});
function _spawnasync() {
    const data = /*#__PURE__*/ _interop_require_default(require("@expo/spawn-async"));
    _spawnasync = function() {
=======
    get: ()=>ADBServer
});
function _spawnAsync() {
    const data = /*#__PURE__*/ _interopRequireDefault(require("@expo/spawn-async"));
    _spawnAsync = function() {
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
        return data;
    };
    return data;
}
<<<<<<< HEAD
function _child_process() {
    const data = require("child_process");
    _child_process = function() {
=======
function _childProcess() {
    const data = require("child_process");
    _childProcess = function() {
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
        return data;
    };
    return data;
}
<<<<<<< HEAD
const _AndroidSdk = require("./AndroidSdk");
=======
const _androidSdk = require("./AndroidSdk");
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
const _log = require("../../../log");
const _env = require("../../../utils/env");
const _errors = require("../../../utils/errors");
const _exit = require("../../../utils/exit");
<<<<<<< HEAD
function _interop_require_default(obj) {
=======
function _interopRequireDefault(obj) {
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
<<<<<<< HEAD
const debug = require('debug')('expo:start:platforms:android:adbServer');
const BEGINNING_OF_ADB_ERROR_MESSAGE = 'error: ';
class ADBServer {
    /** Returns the command line reference to ADB. */ getAdbExecutablePath() {
        try {
            const sdkRoot = (0, _AndroidSdk.assertSdkRoot)();
=======
const debug = require("debug")("expo:start:platforms:android:adbServer");
const BEGINNING_OF_ADB_ERROR_MESSAGE = "error: ";
class ADBServer {
    isRunning = false;
    removeExitHook = ()=>{};
    /** Returns the command line reference to ADB. */ getAdbExecutablePath() {
        try {
            const sdkRoot = (0, _androidSdk.assertSdkRoot)();
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
            if (sdkRoot) {
                return `${sdkRoot}/platform-tools/adb`;
            }
        } catch (error) {
            _log.Log.warn(error.message);
        }
<<<<<<< HEAD
        _log.Log.debug('Failed to resolve the Android SDK path, falling back to global adb executable');
        return 'adb';
=======
        _log.Log.debug("Failed to resolve the Android SDK path, falling back to global adb executable");
        return "adb";
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    }
    /** Start the ADB server. */ async startAsync() {
        if (this.isRunning) {
            return false;
        }
        // clean up
        this.removeExitHook = (0, _exit.installExitHooks)(()=>{
            if (this.isRunning) {
                this.stopAsync();
            }
        });
        const adb = this.getAdbExecutablePath();
<<<<<<< HEAD
        const result = await this.resolveAdbPromise((0, _spawnasync().default)(adb, [
            'start-server'
        ]));
        const lines = result.stderr.trim().split(/\r?\n/);
        const isStarted = lines.includes('* daemon started successfully');
=======
        const result = await this.resolveAdbPromise((0, _spawnAsync().default)(adb, [
            "start-server"
        ]));
        const lines = result.stderr.trim().split(/\r?\n/);
        const isStarted = lines.includes("* daemon started successfully");
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
        this.isRunning = isStarted;
        return isStarted;
    }
    /** Kill the ADB server. */ async stopAsync() {
<<<<<<< HEAD
        debug('Stopping ADB server');
        if (!this.isRunning) {
            debug('ADB server is not running');
=======
        debug("Stopping ADB server");
        if (!this.isRunning) {
            debug("ADB server is not running");
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
            return false;
        }
        this.removeExitHook();
        try {
            await this.runAsync([
<<<<<<< HEAD
                'kill-server'
            ]);
            return true;
        } catch (error) {
            _log.Log.error('Failed to stop ADB server: ' + error.message);
            return false;
        } finally{
            debug('Stopped ADB server');
=======
                "kill-server"
            ]);
            return true;
        } catch (error) {
            _log.Log.error("Failed to stop ADB server: " + error.message);
            return false;
        } finally{
            debug("Stopped ADB server");
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
            this.isRunning = false;
        }
    }
    /** Execute an ADB command with given args. */ async runAsync(args) {
        // TODO: Add a global package that installs adb to the path.
        const adb = this.getAdbExecutablePath();
        await this.startAsync();
        debug([
            adb,
            ...args
<<<<<<< HEAD
        ].join(' '));
        const result = await this.resolveAdbPromise((0, _spawnasync().default)(adb, args));
        return result.output.join('\n');
=======
        ].join(" "));
        const result = await this.resolveAdbPromise((0, _spawnAsync().default)(adb, args));
        return result.output.join("\n");
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    }
    /** Get ADB file output. Useful for reading device state/settings. */ async getFileOutputAsync(args) {
        // TODO: Add a global package that installs adb to the path.
        const adb = this.getAdbExecutablePath();
        await this.startAsync();
<<<<<<< HEAD
        const results = await this.resolveAdbPromise((0, _child_process().execFileSync)(adb, args, {
            encoding: 'latin1',
            stdio: 'pipe'
        }));
        debug('[ADB] File output:\n', results);
=======
        const results = await this.resolveAdbPromise((0, _childProcess().execFileSync)(adb, args, {
            encoding: "latin1",
            stdio: "pipe"
        }));
        debug("[ADB] File output:\n", results);
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
        return results;
    }
    /** Formats error info. */ async resolveAdbPromise(promise) {
        try {
            return await promise;
        } catch (error) {
            // User pressed ctrl+c to cancel the process...
<<<<<<< HEAD
            if (error.signal === 'SIGINT') {
                throw new _errors.AbortCommandError();
            }
            if (error.status === 255 && error.stdout.includes('Bad user number')) {
                var _error_stdout_match;
                const userNumber = ((_error_stdout_match = error.stdout.match(/Bad user number: (.+)/)) == null ? void 0 : _error_stdout_match[1]) ?? _env.env.EXPO_ADB_USER;
                throw new _errors.CommandError('EXPO_ADB_USER', `Invalid ADB user number "${userNumber}" set with environment variable EXPO_ADB_USER. Run "adb shell pm list users" to see valid user numbers.`);
=======
            if (error.signal === "SIGINT") {
                throw new _errors.AbortCommandError();
            }
            if (error.status === 255 && error.stdout.includes("Bad user number")) {
                var ref;
                var ref1;
                const userNumber = (ref1 = (ref = error.stdout.match(/Bad user number: (.+)/)) == null ? void 0 : ref[1]) != null ? ref1 : _env.env.EXPO_ADB_USER;
                throw new _errors.CommandError("EXPO_ADB_USER", `Invalid ADB user number "${userNumber}" set with environment variable EXPO_ADB_USER. Run "adb shell pm list users" to see valid user numbers.`);
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
            }
            // TODO: Support heap corruption for adb 29 (process exits with code -1073740940) (windows and linux)
            let errorMessage = (error.stderr || error.stdout || error.message).trim();
            if (errorMessage.startsWith(BEGINNING_OF_ADB_ERROR_MESSAGE)) {
                errorMessage = errorMessage.substring(BEGINNING_OF_ADB_ERROR_MESSAGE.length);
            }
            error.message = errorMessage;
            throw error;
        }
    }
<<<<<<< HEAD
    constructor(){
        this.isRunning = false;
        this.removeExitHook = ()=>{};
    }
=======
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
}

//# sourceMappingURL=ADBServer.js.map