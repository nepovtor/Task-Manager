"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
<<<<<<< HEAD
    XcodePrerequisite: function() {
        return XcodePrerequisite;
    },
    getXcodeVersionAsync: function() {
        return getXcodeVersionAsync;
    }
});
function _spawnasync() {
    const data = /*#__PURE__*/ _interop_require_default(require("@expo/spawn-async"));
    _spawnasync = function() {
=======
    getXcodeVersionAsync: ()=>getXcodeVersionAsync,
    XcodePrerequisite: ()=>XcodePrerequisite
});
function _spawnAsync() {
    const data = /*#__PURE__*/ _interopRequireDefault(require("@expo/spawn-async"));
    _spawnAsync = function() {
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
        return data;
    };
    return data;
}
function _chalk() {
<<<<<<< HEAD
    const data = /*#__PURE__*/ _interop_require_default(require("chalk"));
=======
    const data = /*#__PURE__*/ _interopRequireDefault(require("chalk"));
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    _chalk = function() {
        return data;
    };
    return data;
}
<<<<<<< HEAD
function _child_process() {
    const data = require("child_process");
    _child_process = function() {
=======
function _childProcess() {
    const data = require("child_process");
    _childProcess = function() {
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
        return data;
    };
    return data;
}
function _semver() {
<<<<<<< HEAD
    const data = /*#__PURE__*/ _interop_require_default(require("semver"));
=======
    const data = /*#__PURE__*/ _interopRequireDefault(require("semver"));
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    _semver = function() {
        return data;
    };
    return data;
}
<<<<<<< HEAD
const _log = /*#__PURE__*/ _interop_require_wildcard(require("../../../log"));
const _errors = require("../../../utils/errors");
const _profile = require("../../../utils/profile");
const _prompts = require("../../../utils/prompts");
const _Prerequisite = require("../Prerequisite");
function _interop_require_default(obj) {
=======
const _log = /*#__PURE__*/ _interopRequireWildcard(require("../../../log"));
const _errors = require("../../../utils/errors");
const _profile = require("../../../utils/profile");
const _prompts = require("../../../utils/prompts");
const _prerequisite = require("../Prerequisite");
function _interopRequireDefault(obj) {
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
<<<<<<< HEAD
function _interop_require_wildcard(obj, nodeInterop) {
=======
function _interopRequireWildcard(obj, nodeInterop) {
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
<<<<<<< HEAD
    var newObj = {
        __proto__: null
    };
=======
    var newObj = {};
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
<<<<<<< HEAD
const debug = require('debug')('expo:doctor:apple:xcode');
// Based on the Apple announcement (last updated: Aug 2023).
// https://developer.apple.com/news/upcoming-requirements/?id=04252023a
const MIN_XCODE_VERSION = '14.1';
const APP_STORE_ID = '497799835';
=======
const debug = require("debug")("expo:doctor:apple:xcode");
// Based on the Apple announcement (last updated: Aug 2023).
// https://developer.apple.com/news/upcoming-requirements/?id=04252023a
const MIN_XCODE_VERSION = "14.1";
const APP_STORE_ID = "497799835";
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
const SUGGESTED_XCODE_VERSION = `${MIN_XCODE_VERSION}.0`;
const promptToOpenAppStoreAsync = async (message)=>{
    // This prompt serves no purpose accept informing the user what to do next, we could just open the App Store but it could be confusing if they don't know what's going on.
    const confirm = await (0, _prompts.confirmAsync)({
        initial: true,
        message
    });
    if (confirm) {
        _log.log(`Going to the App Store, re-run Expo CLI when Xcode has finished installing.`);
        openAppStore(APP_STORE_ID);
    }
};
let _xcodeVersionPromise = null;
<<<<<<< HEAD
const getXcodeVersionAsync = async ({ silent, force } = {})=>{
    const logError = silent ? debug : _log.warn;
    const getVersion = async ()=>{
        try {
            var _stdout_match;
            const { stdout } = await (0, _spawnasync().default)('xcodebuild', [
                '-version'
            ]);
            const last = (_stdout_match = stdout.match(/^Xcode (\d+\.\d+)/)) == null ? void 0 : _stdout_match[1];
=======
const getXcodeVersionAsync = async ({ silent , force  } = {})=>{
    const logError = silent ? debug : _log.warn;
    const getVersion = async ()=>{
        try {
            var ref;
            const { stdout  } = await (0, _spawnAsync().default)("xcodebuild", [
                "-version"
            ]);
            const last = (ref = stdout.match(/^Xcode (\d+\.\d+)/)) == null ? void 0 : ref[1];
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
            // Convert to a semver string
            if (last) {
                const version = `${last}.0`;
                if (!_semver().default.valid(version)) {
                    // Not sure why this would happen, if it does we should add a more confident error message.
                    return {
                        error: `Xcode version is in an unknown format: ${version}`,
                        value: false
                    };
                }
                return {
                    value: version
                };
            }
            // not sure what's going on
            return {
<<<<<<< HEAD
                error: 'Unable to check Xcode version. Command ran successfully but no version number was found.',
=======
                error: "Unable to check Xcode version. Command ran successfully but no version number was found.",
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
                value: null
            };
        } catch  {
        // not installed
        }
        return {
            value: null
        };
    };
    if (force) {
        _xcodeVersionPromise = null;
    }
<<<<<<< HEAD
    _xcodeVersionPromise = _xcodeVersionPromise ?? getVersion();
=======
    _xcodeVersionPromise = _xcodeVersionPromise != null ? _xcodeVersionPromise : getVersion();
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    const result = await _xcodeVersionPromise;
    if (result.error) {
        logError(result.error);
    }
    return result.value;
};
/**
 * Open a link to the App Store. Just link in mobile apps, **never** redirect without prompting first.
 *
 * @param appId
 */ function openAppStore(appId) {
    const link = getAppStoreLink(appId);
<<<<<<< HEAD
    (0, _child_process().execSync)(`open ${link}`, {
        stdio: 'ignore'
    });
}
function getAppStoreLink(appId) {
    if (process.platform === 'darwin') {
=======
    (0, _childProcess().execSync)(`open ${link}`, {
        stdio: "ignore"
    });
}
function getAppStoreLink(appId) {
    if (process.platform === "darwin") {
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
        // TODO: Is there ever a case where the macappstore isn't available on mac?
        return `macappstore://itunes.apple.com/app/id${appId}`;
    }
    return `https://apps.apple.com/us/app/id${appId}`;
}
function spawnForString(cmd) {
    try {
<<<<<<< HEAD
        return (0, _child_process().execSync)(cmd, {
            stdio: 'pipe'
=======
        return (0, _childProcess().execSync)(cmd, {
            stdio: "pipe"
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
        }).toString().trim();
    } catch  {}
    return null;
}
/** @returns a string like `/Applications/Xcode.app/Contents/Developer` when Xcode has a correctly selected path. */ function getXcodeSelectPathAsync() {
<<<<<<< HEAD
    return spawnForString('/usr/bin/xcode-select --print-path');
}
function getXcodeInstalled() {
    return spawnForString('ls /Applications/Xcode.app/Contents/Developer');
}
class XcodePrerequisite extends _Prerequisite.Prerequisite {
    static #_ = this.instance = new XcodePrerequisite();
=======
    return spawnForString("/usr/bin/xcode-select --print-path");
}
function getXcodeInstalled() {
    return spawnForString("ls /Applications/Xcode.app/Contents/Developer");
}
class XcodePrerequisite extends _prerequisite.Prerequisite {
    static instance = new XcodePrerequisite();
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    /**
   * Ensure Xcode is installed and recent enough to be used with Expo.
   */ async assertImplementation() {
        const version = await (0, _profile.profile)(getXcodeVersionAsync)({
<<<<<<< HEAD
            force: process.env.NODE_ENV === 'test'
=======
            force: process.env.NODE_ENV === "test"
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
        });
        debug(`Xcode version: ${version}`);
        if (!version) {
            // A couple different issues could have occurred, let's check them after we're past the point of no return
            // since we no longer need to be fast about validation.
            // Ensure Xcode.app can be found before we prompt to sudo select it.
            if (getXcodeInstalled()) {
                const selectPath = (0, _profile.profile)(getXcodeSelectPathAsync)();
                debug(`Xcode select path: ${selectPath}`);
                if (!selectPath) {
                    _log.error([
<<<<<<< HEAD
                        '',
                        _chalk().default.bold('Xcode has not been fully setup for Apple development yet.'),
                        'Download at: https://developer.apple.com/xcode/',
                        'or in the App Store.',
                        '',
                        'After downloading Xcode, run the following two commands in your terminal:',
                        _chalk().default.cyan('  sudo xcode-select --switch /Applications/Xcode.app/Contents/Developer'),
                        _chalk().default.cyan('  sudo xcodebuild -runFirstLaunch'),
                        '',
                        'Then you can re-run Expo CLI. Alternatively, you can build apps in the cloud with EAS CLI, or preview using the Expo Go app on a physical device.',
                        ''
                    ].join('\n'));
=======
                        "",
                        _chalk().default.bold("Xcode has not been fully setup for Apple development yet."),
                        "Download at: https://developer.apple.com/xcode/",
                        "or in the App Store.",
                        "",
                        "After downloading Xcode, run the following two commands in your terminal:",
                        _chalk().default.cyan("  sudo xcode-select --switch /Applications/Xcode.app/Contents/Developer"),
                        _chalk().default.cyan("  sudo xcodebuild -runFirstLaunch"),
                        "",
                        "Then you can re-run Expo CLI. Alternatively, you can build apps in the cloud with EAS CLI, or preview using the Expo Go app on a physical device.",
                        "", 
                    ].join("\n"));
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
                    throw new _errors.AbortCommandError();
                } else {
                    debug(`Unexpected Xcode setup (version: ${version}, select: ${selectPath})`);
                }
            }
            // Almost certainly Xcode isn't installed.
<<<<<<< HEAD
            await promptToOpenAppStoreAsync(`Xcode must be fully installed before you can continue. If this message is still occurring after installing Xcode, you may need to finish the installation of the developer tools by running: \`sudo xcode-select -s /Applications/Xcode.app/Contents/Developer\`. Continue to the App Store?`);
=======
            await promptToOpenAppStoreAsync(`Xcode must be fully installed before you can continue. Continue to the App Store?`);
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
            throw new _errors.AbortCommandError();
        }
        if (_semver().default.lt(version, SUGGESTED_XCODE_VERSION)) {
            // Xcode version is too old.
            await promptToOpenAppStoreAsync(`Xcode (${version}) needs to be updated to at least version ${MIN_XCODE_VERSION}. Continue to the App Store?`);
            throw new _errors.AbortCommandError();
        }
    }
}

//# sourceMappingURL=XcodePrerequisite.js.map