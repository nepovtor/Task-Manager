/**
 * Copyright Â© 2022 650 Industries.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
<<<<<<< HEAD
    fetchManifest: function() {
        return fetchManifest;
    },
    inflateManifest: function() {
        return inflateManifest;
    }
});
function _resolvefrom() {
    const data = /*#__PURE__*/ _interop_require_default(require("resolve-from"));
    _resolvefrom = function() {
=======
    fetchManifest: ()=>fetchManifest,
    inflateManifest: ()=>inflateManifest
});
function _resolveFrom() {
    const data = /*#__PURE__*/ _interopRequireDefault(require("resolve-from"));
    _resolveFrom = function() {
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
        return data;
    };
    return data;
}
const _router = require("./router");
<<<<<<< HEAD
function _interop_require_default(obj) {
=======
function _interopRequireDefault(obj) {
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function getExpoRouteManifestBuilderAsync(projectRoot) {
<<<<<<< HEAD
    return require((0, _resolvefrom().default)(projectRoot, 'expo-router/build/routes-manifest')).createRoutesManifest;
=======
    return require((0, _resolveFrom().default)(projectRoot, "expo-router/build/routes-manifest")).createRoutesManifest;
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
}
async function fetchManifest(projectRoot, options) {
    const getManifest = getExpoRouteManifestBuilderAsync(projectRoot);
    const paths = (0, _router.getRoutePaths)(options.appDir);
    // Get the serialized manifest
    const jsonManifest = getManifest(paths, options);
    if (!jsonManifest) {
        return null;
    }
    if (!jsonManifest.htmlRoutes || !jsonManifest.apiRoutes) {
<<<<<<< HEAD
        throw new Error('Routes manifest is malformed: ' + JSON.stringify(jsonManifest, null, 2));
=======
        throw new Error("Routes manifest is malformed: " + JSON.stringify(jsonManifest, null, 2));
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    }
    if (!options.asJson) {
        // @ts-expect-error
        return inflateManifest(jsonManifest);
    }
    // @ts-expect-error
    return jsonManifest;
}
function inflateManifest(json) {
<<<<<<< HEAD
    var _json_htmlRoutes, _json_apiRoutes, _json_notFoundRoutes, _json_redirects, _json_rewrites;
    return {
        ...json,
        htmlRoutes: (_json_htmlRoutes = json.htmlRoutes) == null ? void 0 : _json_htmlRoutes.map((value)=>{
=======
    var ref, ref1, ref2;
    return {
        ...json,
        htmlRoutes: (ref = json.htmlRoutes) == null ? void 0 : ref.map((value)=>{
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
            return {
                ...value,
                namedRegex: new RegExp(value.namedRegex)
            };
        }),
<<<<<<< HEAD
        apiRoutes: (_json_apiRoutes = json.apiRoutes) == null ? void 0 : _json_apiRoutes.map((value)=>{
=======
        apiRoutes: (ref1 = json.apiRoutes) == null ? void 0 : ref1.map((value)=>{
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
            return {
                ...value,
                namedRegex: new RegExp(value.namedRegex)
            };
        }),
<<<<<<< HEAD
        notFoundRoutes: (_json_notFoundRoutes = json.notFoundRoutes) == null ? void 0 : _json_notFoundRoutes.map((value)=>{
            return {
                ...value,
                namedRegex: new RegExp(value.namedRegex)
            };
        }),
        redirects: (_json_redirects = json.redirects) == null ? void 0 : _json_redirects.map((value)=>{
            return {
                ...value,
                namedRegex: new RegExp(value.namedRegex)
            };
        }),
        rewrites: (_json_rewrites = json.rewrites) == null ? void 0 : _json_rewrites.map((value)=>{
=======
        notFoundRoutes: (ref2 = json.notFoundRoutes) == null ? void 0 : ref2.map((value)=>{
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
            return {
                ...value,
                namedRegex: new RegExp(value.namedRegex)
            };
        })
    };
}

//# sourceMappingURL=fetchRouterManifest.js.map