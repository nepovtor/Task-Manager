"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
<<<<<<< HEAD
    openJsInspector: function() {
        return openJsInspector;
    },
    promptInspectorAppAsync: function() {
        return promptInspectorAppAsync;
    },
    queryAllInspectorAppsAsync: function() {
        return queryAllInspectorAppsAsync;
    },
    queryInspectorAppAsync: function() {
        return queryInspectorAppAsync;
    }
});
function _chalk() {
    const data = /*#__PURE__*/ _interop_require_default(require("chalk"));
=======
    openJsInspector: ()=>openJsInspector,
    closeJsInspector: ()=>closeJsInspector,
    queryInspectorAppAsync: ()=>queryInspectorAppAsync,
    queryAllInspectorAppsAsync: ()=>queryAllInspectorAppsAsync
});
function _chalk() {
    const data = /*#__PURE__*/ _interopRequireDefault(require("chalk"));
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    _chalk = function() {
        return data;
    };
    return data;
}
<<<<<<< HEAD
const _CdpClient = require("./CdpClient");
const _prompts = require("../../../../utils/prompts");
const _pageIsSupported = require("../../metro/debugging/pageIsSupported");
function _interop_require_default(obj) {
=======
function _nodeFetch() {
    const data = /*#__PURE__*/ _interopRequireDefault(require("node-fetch"));
    _nodeFetch = function() {
        return data;
    };
    return data;
}
const _launchBrowser = require("./LaunchBrowser");
const _log = require("../../../../log");
const _env = require("../../../../utils/env");
const _pageIsSupported = require("../../metro/debugging/pageIsSupported");
function _interopRequireDefault(obj) {
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
<<<<<<< HEAD
const debug = require('debug')('expo:start:server:middleware:inspector:jsInspector');
async function openJsInspector(metroBaseUrl, app) {
    var _app_reactNative;
    if (!((_app_reactNative = app.reactNative) == null ? void 0 : _app_reactNative.logicalDeviceId)) {
        debug('Failed to open React Native DevTools, target is missing device ID');
        return false;
    }
    const url = new URL('/open-debugger', metroBaseUrl);
    url.searchParams.set('target', app.id);
    // Request to open the React Native DevTools, but limit it to 1s
    // This is a workaround as this endpoint might not respond on some devices
    const response = await fetch(url, {
        method: 'POST',
        signal: AbortSignal.timeout(1000)
    }).catch((error)=>{
        // Only swallow timeout errors
        if (error.name === 'TimeoutError') {
            return null;
        }
        throw error;
    });
    if (!response) {
        debug(`No response received from the React Native DevTools.`);
    } else if (response.ok === false) {
        debug('Failed to open React Native DevTools, received response:', response.status);
    }
    return (response == null ? void 0 : response.ok) ?? true;
}
async function queryInspectorAppAsync(metroServerOrigin, appId) {
    const apps = await queryAllInspectorAppsAsync(metroServerOrigin);
    return apps.find((app)=>app.appId === appId) ?? null;
}
async function queryAllInspectorAppsAsync(metroServerOrigin) {
    const resp = await fetch(`${metroServerOrigin}/json/list`);
    // The newest runtime will be at the end of the list,
    // reversing the result would save time from try-error.
    const apps = (await resp.json()).reverse();
    const results = [];
    for (const app of apps){
        // Only use targets with better reloading support
        if (!(0, _pageIsSupported.pageIsSupported)(app)) {
            continue;
        }
        try {
            // Hide targets that are marked as hidden from the inspector, e.g. instances from expo-dev-menu and expo-dev-launcher.
            if (await appShouldBeIgnoredAsync(app)) {
                continue;
            }
        } catch (e) {
            // If we can't evaluate the JS, we just ignore the error and skips the target.
            debug(`Can't evaluate the JS on the app:`, JSON.stringify(e, null, 2));
            continue;
        }
        results.push(app);
    }
    return results;
}
async function promptInspectorAppAsync(apps) {
    var _choices_find;
    if (apps.length === 1) {
        return apps[0];
    }
    // Check if multiple devices are connected with the same device names
    // In this case, append the actual app id (device ID + page number) to the prompt
    const hasDuplicateNames = apps.some((app, index)=>index !== apps.findIndex((other)=>app.deviceName === other.deviceName));
    const choices = apps.map((app)=>{
        const name = app.deviceName ?? 'Unknown device';
        return {
            title: hasDuplicateNames ? (0, _chalk().default)`${name}{dim  - ${app.id}}` : name,
            value: app.id,
            app
        };
    });
    const value = await (0, _prompts.selectAsync)((0, _chalk().default)`Debug target {dim (Hermes only)}`, choices);
    return (_choices_find = choices.find((item)=>item.value === value)) == null ? void 0 : _choices_find.app;
}
const HIDE_FROM_INSPECTOR_ENV = 'globalThis.__expo_hide_from_inspector__';
async function appShouldBeIgnoredAsync(app) {
    const hideFromInspector = await (0, _CdpClient.evaluateJsFromCdpAsync)(app.webSocketDebuggerUrl, HIDE_FROM_INSPECTOR_ENV);
    debug(`[appShouldBeIgnoredAsync] webSocketDebuggerUrl[${app.webSocketDebuggerUrl}] hideFromInspector[${hideFromInspector}]`);
    return hideFromInspector !== undefined;
=======
let openingBrowserInstance = null;
function openJsInspector(metroBaseUrl, app) {
    if (_env.env.EXPO_USE_UNSTABLE_DEBUGGER) {
        return openExperimentalJsInspector(metroBaseUrl, app);
    } else {
        return openClassicJsInspector(app);
    }
}
async function openExperimentalJsInspector(metroBaseUrl, app) {
    const device = encodeURIComponent(app.id);
    const appId = encodeURIComponent(app.description);
    await (0, _nodeFetch().default)(`${metroBaseUrl}/open-debugger?device=${device}&appId=${appId}`, {
        method: "POST"
    });
}
/**
 * Chrome DevTools UI implemented for SDK <49.
 * TODO(cedric): Remove this when we fully swap over to the new React Native JS Inspector.
 */ async function openClassicJsInspector(app) {
    _log.Log.log((0, _chalk().default)`{bold Debug:} Opening JavaScript inspector in the browser...`);
    // To update devtoolsFrontendRev, find the full commit hash in the url:
    // https://chromium.googlesource.com/chromium/src.git/+log/refs/tags/{CHROME_VERSION}/chrome/VERSION
    //
    // 1. Replace {CHROME_VERSION} with the target chrome version
    // 2. Click the first log item in the webpage
    // 3. The full commit hash is the desired revision
    const devtoolsFrontendRev = "d9568d04d7dd79269c5a655d7ada69650c5a8336"; // Chrome 100.0.4896.75
    const urlBase = `https://chrome-devtools-frontend.appspot.com/serve_rev/@${devtoolsFrontendRev}/devtools_app.html`;
    const ws = app.webSocketDebuggerUrl.replace(/^ws:\/\//, "");
    const url = `${urlBase}?panel=console&ws=${encodeURIComponent(ws)}`;
    await closeJsInspector();
    openingBrowserInstance = await (0, _launchBrowser.launchInspectorBrowserAsync)(url);
}
async function closeJsInspector() {
    await (openingBrowserInstance == null ? void 0 : openingBrowserInstance.close());
    openingBrowserInstance = null;
}
async function queryInspectorAppAsync(metroServerOrigin, appId) {
    const apps = await queryAllInspectorAppsAsync(metroServerOrigin);
    var ref;
    return (ref = apps.find((app)=>app.description === appId)) != null ? ref : null;
}
async function queryAllInspectorAppsAsync(metroServerOrigin) {
    const resp = await (0, _nodeFetch().default)(`${metroServerOrigin}/json/list`);
    const apps = transformApps(await resp.json());
    // Only use targets with better reloading support
    return apps.filter((app)=>(0, _pageIsSupported.pageIsSupported)(app));
}
// The description of `React Native Experimental (Improved Chrome Reloads)` target is `don't use` from metro.
// This function tries to transform the unmeaningful description to appId
function transformApps(apps) {
    const deviceIdToAppId = {};
    for (const app of apps){
        if (app.description !== "don't use") {
            var ref;
            var ref1;
            const deviceId = (ref1 = (ref = app.reactNative) == null ? void 0 : ref.logicalDeviceId) != null ? ref1 : app.id.split("-")[0];
            const appId = app.description;
            deviceIdToAppId[deviceId] = appId;
        }
    }
    return apps.map((app)=>{
        if (app.description === "don't use") {
            var ref;
            var ref1;
            const deviceId = (ref1 = (ref = app.reactNative) == null ? void 0 : ref.logicalDeviceId) != null ? ref1 : app.id.split("-")[0];
            var _deviceId;
            app.description = (_deviceId = deviceIdToAppId[deviceId]) != null ? _deviceId : app.description;
        }
        return app;
    });
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
}

//# sourceMappingURL=JsInspector.js.map