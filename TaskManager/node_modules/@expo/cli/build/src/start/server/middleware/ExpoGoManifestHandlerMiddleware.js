"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
<<<<<<< HEAD
    ExpoGoManifestHandlerMiddleware: function() {
        return ExpoGoManifestHandlerMiddleware;
    },
    ResponseContentType: function() {
        return ResponseContentType;
    }
});
function _configplugins() {
    const data = require("@expo/config-plugins");
    _configplugins = function() {
=======
    ResponseContentType: ()=>ResponseContentType,
    ExpoGoManifestHandlerMiddleware: ()=>ExpoGoManifestHandlerMiddleware
});
function _configPlugins() {
    const data = require("@expo/config-plugins");
    _configPlugins = function() {
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
        return data;
    };
    return data;
}
function _accepts() {
<<<<<<< HEAD
    const data = /*#__PURE__*/ _interop_require_default(require("accepts"));
=======
    const data = /*#__PURE__*/ _interopRequireDefault(require("accepts"));
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    _accepts = function() {
        return data;
    };
    return data;
}
function _crypto() {
<<<<<<< HEAD
    const data = /*#__PURE__*/ _interop_require_default(require("crypto"));
=======
    const data = /*#__PURE__*/ _interopRequireDefault(require("crypto"));
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    _crypto = function() {
        return data;
    };
    return data;
}
<<<<<<< HEAD
function _structuredheaders() {
    const data = require("structured-headers");
    _structuredheaders = function() {
=======
function _formData() {
    const data = /*#__PURE__*/ _interopRequireDefault(require("form-data"));
    _formData = function() {
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
        return data;
    };
    return data;
}
<<<<<<< HEAD
const _ManifestMiddleware = require("./ManifestMiddleware");
const _resolvePlatform = require("./resolvePlatform");
const _resolveRuntimeVersionWithExpoUpdatesAsync = require("./resolveRuntimeVersionWithExpoUpdatesAsync");
const _UserSettings = require("../../../api/user/UserSettings");
const _user = require("../../../api/user/user");
const _codesigning = require("../../../utils/codesigning");
const _errors = require("../../../utils/errors");
const _multipartMixed = require("../../../utils/multipartMixed");
const _url = require("../../../utils/url");
function _interop_require_default(obj) {
=======
function _structuredHeaders() {
    const data = require("structured-headers");
    _structuredHeaders = function() {
        return data;
    };
    return data;
}
const _manifestMiddleware = require("./ManifestMiddleware");
const _resolvePlatform = require("./resolvePlatform");
const _userSettings = /*#__PURE__*/ _interopRequireDefault(require("../../../api/user/UserSettings"));
const _user = require("../../../api/user/user");
const _codesigning = require("../../../utils/codesigning");
const _errors = require("../../../utils/errors");
const _telemetry = require("../../../utils/telemetry");
const _url = require("../../../utils/url");
function _interopRequireDefault(obj) {
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
<<<<<<< HEAD
const debug = require('debug')('expo:start:server:middleware:ExpoGoManifestHandlerMiddleware');
var ResponseContentType = /*#__PURE__*/ function(ResponseContentType) {
=======
const debug = require("debug")("expo:start:server:middleware:ExpoGoManifestHandlerMiddleware");
var ResponseContentType;
(function(ResponseContentType) {
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    ResponseContentType[ResponseContentType["TEXT_PLAIN"] = 0] = "TEXT_PLAIN";
    ResponseContentType[ResponseContentType["APPLICATION_JSON"] = 1] = "APPLICATION_JSON";
    ResponseContentType[ResponseContentType["APPLICATION_EXPO_JSON"] = 2] = "APPLICATION_EXPO_JSON";
    ResponseContentType[ResponseContentType["MULTIPART_MIXED"] = 3] = "MULTIPART_MIXED";
<<<<<<< HEAD
    return ResponseContentType;
}({});
class ExpoGoManifestHandlerMiddleware extends _ManifestMiddleware.ManifestMiddleware {
=======
})(ResponseContentType || (ResponseContentType = {}));
class ExpoGoManifestHandlerMiddleware extends _manifestMiddleware.ManifestMiddleware {
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    getParsedHeaders(req) {
        let platform = (0, _resolvePlatform.parsePlatformHeader)(req);
        if (!platform) {
            debug(`No "expo-platform" header or "platform" query parameter specified. Falling back to "ios".`);
<<<<<<< HEAD
            platform = 'ios';
=======
            platform = "ios";
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
        }
        (0, _resolvePlatform.assertRuntimePlatform)(platform);
        // Expo Updates clients explicitly accept "multipart/mixed" responses while browsers implicitly
        // accept them with "accept: */*". To make it easier to debug manifest responses by visiting their
        // URLs in a browser, we denote the response as "text/plain" if the user agent appears not to be
        // an Expo Updates client.
        const accept = (0, _accepts().default)(req);
        const acceptedType = accept.types([
<<<<<<< HEAD
            'unknown/unknown',
            'multipart/mixed',
            'application/json',
            'application/expo+json',
            'text/plain'
        ]);
        let responseContentType;
        switch(acceptedType){
            case 'multipart/mixed':
                responseContentType = 3;
                break;
            case 'application/json':
                responseContentType = 1;
                break;
            case 'application/expo+json':
=======
            "unknown/unknown",
            "multipart/mixed",
            "application/json",
            "application/expo+json",
            "text/plain", 
        ]);
        let responseContentType;
        switch(acceptedType){
            case "multipart/mixed":
                responseContentType = 3;
                break;
            case "application/json":
                responseContentType = 1;
                break;
            case "application/expo+json":
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
                responseContentType = 2;
                break;
            default:
                responseContentType = 0;
                break;
        }
<<<<<<< HEAD
        const expectSignature = req.headers['expo-expect-signature'];
=======
        const expectSignature = req.headers["expo-expect-signature"];
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
        return {
            responseContentType,
            platform,
            expectSignature: expectSignature ? String(expectSignature) : null,
<<<<<<< HEAD
            hostname: (0, _url.stripPort)(req.headers['host']),
            protocol: req.headers['x-forwarded-proto']
=======
            hostname: (0, _url.stripPort)(req.headers["host"]),
            protocol: req.headers["x-forwarded-proto"]
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
        };
    }
    getDefaultResponseHeaders() {
        const headers = new Map();
        // set required headers for Expo Updates manifest specification
<<<<<<< HEAD
        headers.set('expo-protocol-version', 0);
        headers.set('expo-sfv-version', 0);
        headers.set('cache-control', 'private, max-age=0');
        return headers;
    }
    async _getManifestResponseAsync(requestOptions) {
        var _exp_extra_eas, _exp_extra;
        const { exp, hostUri, expoGoConfig, bundleUrl } = await this._resolveProjectSettingsAsync(requestOptions);
        const runtimeVersion = await (0, _resolveRuntimeVersionWithExpoUpdatesAsync.resolveRuntimeVersionWithExpoUpdatesAsync)({
            projectRoot: this.projectRoot,
            platform: requestOptions.platform
        }) ?? // if expo-updates can't determine runtime version, fall back to calculation from config-plugin.
        // this happens when expo-updates is installed but runtimeVersion hasn't yet been configured or when
        // expo-updates is not installed.
        await _configplugins().Updates.getRuntimeVersionAsync(this.projectRoot, {
            ...exp,
            runtimeVersion: exp.runtimeVersion ?? {
                policy: 'sdkVersion'
            }
        }, requestOptions.platform);
        if (!runtimeVersion) {
            throw new _errors.CommandError('MANIFEST_MIDDLEWARE', `Unable to determine runtime version for platform '${requestOptions.platform}'`);
        }
        const codeSigningInfo = await (0, _codesigning.getCodeSigningInfoAsync)(exp, requestOptions.expectSignature, this.options.privateKeyPath);
        const easProjectId = (_exp_extra = exp.extra) == null ? void 0 : (_exp_extra_eas = _exp_extra.eas) == null ? void 0 : _exp_extra_eas.projectId;
=======
        headers.set("expo-protocol-version", 0);
        headers.set("expo-sfv-version", 0);
        headers.set("cache-control", "private, max-age=0");
        return headers;
    }
    async _getManifestResponseAsync(requestOptions) {
        var ref, ref1;
        const { exp , hostUri , expoGoConfig , bundleUrl  } = await this._resolveProjectSettingsAsync(requestOptions);
        var _runtimeVersion;
        const runtimeVersion = await _configPlugins().Updates.getRuntimeVersionAsync(this.projectRoot, {
            ...exp,
            runtimeVersion: (_runtimeVersion = exp.runtimeVersion) != null ? _runtimeVersion : {
                policy: "sdkVersion"
            }
        }, requestOptions.platform);
        if (!runtimeVersion) {
            throw new _errors.CommandError("MANIFEST_MIDDLEWARE", `Unable to determine runtime version for platform '${requestOptions.platform}'`);
        }
        const codeSigningInfo = await (0, _codesigning.getCodeSigningInfoAsync)(exp, requestOptions.expectSignature, this.options.privateKeyPath);
        const easProjectId = (ref = exp.extra) == null ? void 0 : (ref1 = ref.eas) == null ? void 0 : ref1.projectId;
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
        const scopeKey = await ExpoGoManifestHandlerMiddleware.getScopeKeyAsync({
            slug: exp.slug,
            codeSigningInfo
        });
        const expoUpdatesManifest = {
            id: _crypto().default.randomUUID(),
            createdAt: new Date().toISOString(),
            runtimeVersion,
            launchAsset: {
<<<<<<< HEAD
                key: 'bundle',
                contentType: 'application/javascript',
=======
                key: "bundle",
                contentType: "application/javascript",
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
                url: bundleUrl
            },
            assets: [],
            metadata: {},
            extra: {
                eas: {
<<<<<<< HEAD
                    projectId: easProjectId ?? undefined
=======
                    projectId: easProjectId != null ? easProjectId : undefined
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
                },
                expoClient: {
                    ...exp,
                    hostUri
                },
                expoGo: expoGoConfig,
                scopeKey
            }
        };
        const stringifiedManifest = JSON.stringify(expoUpdatesManifest);
        let manifestPartHeaders = null;
        let certificateChainBody = null;
        if (codeSigningInfo) {
            const signature = (0, _codesigning.signManifestString)(stringifiedManifest, codeSigningInfo);
            manifestPartHeaders = {
<<<<<<< HEAD
                'expo-signature': (0, _structuredheaders().serializeDictionary)(convertToDictionaryItemsRepresentation({
                    keyid: codeSigningInfo.keyId,
                    sig: signature,
                    alg: 'rsa-v1_5-sha256'
                }))
            };
            certificateChainBody = codeSigningInfo.certificateChainForResponse.join('\n');
=======
                "expo-signature": (0, _structuredHeaders().serializeDictionary)(convertToDictionaryItemsRepresentation({
                    keyid: codeSigningInfo.keyId,
                    sig: signature,
                    alg: "rsa-v1_5-sha256"
                }))
            };
            certificateChainBody = codeSigningInfo.certificateChainForResponse.join("\n");
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
        }
        const headers = this.getDefaultResponseHeaders();
        switch(requestOptions.responseContentType){
            case 3:
                {
<<<<<<< HEAD
                    const encoded = await this.encodeFormDataAsync({
=======
                    const form = this.getFormData({
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
                        stringifiedManifest,
                        manifestPartHeaders,
                        certificateChainBody
                    });
<<<<<<< HEAD
                    headers.set('content-type', `multipart/mixed; boundary=${encoded.boundary}`);
                    return {
                        body: encoded.body,
=======
                    headers.set("content-type", `multipart/mixed; boundary=${form.getBoundary()}`);
                    return {
                        body: form.getBuffer().toString(),
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
                        version: runtimeVersion,
                        headers
                    };
                }
            case 2:
            case 1:
            case 0:
                {
<<<<<<< HEAD
                    headers.set('content-type', ExpoGoManifestHandlerMiddleware.getContentTypeForResponseContentType(requestOptions.responseContentType));
=======
                    headers.set("content-type", ExpoGoManifestHandlerMiddleware.getContentTypeForResponseContentType(requestOptions.responseContentType));
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
                    if (manifestPartHeaders) {
                        Object.entries(manifestPartHeaders).forEach(([key, value])=>{
                            headers.set(key, value);
                        });
                    }
                    return {
                        body: stringifiedManifest,
                        version: runtimeVersion,
                        headers
                    };
                }
        }
    }
    static getContentTypeForResponseContentType(responseContentType) {
        switch(responseContentType){
            case 3:
<<<<<<< HEAD
                return 'multipart/mixed';
            case 2:
                return 'application/expo+json';
            case 1:
                return 'application/json';
            case 0:
                return 'text/plain';
        }
    }
    encodeFormDataAsync({ stringifiedManifest, manifestPartHeaders, certificateChainBody }) {
        const fields = [
            {
                name: 'manifest',
                value: stringifiedManifest,
                contentType: 'application/json',
                partHeaders: manifestPartHeaders
            }
        ];
        if (certificateChainBody && certificateChainBody.length > 0) {
            fields.push({
                name: 'certificate_chain',
                value: certificateChainBody,
                contentType: 'application/x-pem-file'
            });
        }
        return (0, _multipartMixed.encodeMultipartMixed)(fields);
    }
    static async getScopeKeyAsync({ slug, codeSigningInfo }) {
=======
                return "multipart/mixed";
            case 2:
                return "application/expo+json";
            case 1:
                return "application/json";
            case 0:
                return "text/plain";
        }
    }
    getFormData({ stringifiedManifest , manifestPartHeaders , certificateChainBody  }) {
        const form = new (_formData()).default();
        form.append("manifest", stringifiedManifest, {
            contentType: "application/json",
            header: {
                ...manifestPartHeaders
            }
        });
        if (certificateChainBody && certificateChainBody.length > 0) {
            form.append("certificate_chain", certificateChainBody, {
                contentType: "application/x-pem-file"
            });
        }
        return form;
    }
    trackManifest(version) {
        (0, _telemetry.logEventAsync)("Serve Expo Updates Manifest", {
            runtimeVersion: version
        });
    }
    static async getScopeKeyAsync({ slug , codeSigningInfo  }) {
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
        const scopeKeyFromCodeSigningInfo = codeSigningInfo == null ? void 0 : codeSigningInfo.scopeKey;
        if (scopeKeyFromCodeSigningInfo) {
            return scopeKeyFromCodeSigningInfo;
        }
        // Log.warn(
        //   env.EXPO_OFFLINE
        //     ? 'Using anonymous scope key in manifest for offline mode.'
        //     : 'Using anonymous scope key in manifest.'
        // );
        return await getAnonymousScopeKeyAsync(slug);
    }
}
async function getAnonymousScopeKeyAsync(slug) {
<<<<<<< HEAD
    const userAnonymousIdentifier = await (0, _UserSettings.getAnonymousIdAsync)();
=======
    const userAnonymousIdentifier = await _userSettings.default.getAnonymousIdentifierAsync();
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    return `@${_user.ANONYMOUS_USERNAME}/${slug}-${userAnonymousIdentifier}`;
}
function convertToDictionaryItemsRepresentation(obj) {
    return new Map(Object.entries(obj).map(([k, v])=>{
        return [
            k,
            [
                v,
                new Map()
            ]
        ];
    }));
}

//# sourceMappingURL=ExpoGoManifestHandlerMiddleware.js.map