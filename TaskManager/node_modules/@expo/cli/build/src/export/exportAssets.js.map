<<<<<<< HEAD
{"version":3,"sources":["../../../src/export/exportAssets.ts"],"sourcesContent":["import { ExpoConfig } from '@expo/config';\nimport fs from 'fs';\nimport { minimatch } from 'minimatch';\nimport path from 'path';\n\nimport { getAssetIdForLogGrouping, persistMetroAssetsAsync } from './persistMetroAssets';\nimport type { Asset, BundleAssetWithFileHashes, BundleOutput, ExportAssetMap } from './saveAssets';\nimport * as Log from '../log';\nimport { resolveGoogleServicesFile } from '../start/server/middleware/resolveAssets';\nimport { uniqBy } from '../utils/array';\n\nconst debug = require('debug')('expo:export:exportAssets') as typeof console.log;\n\nfunction mapAssetHashToAssetString(asset: Asset, hash: string) {\n  return 'asset_' + hash + ('type' in asset && asset.type ? '.' + asset.type : '');\n}\n\nexport function assetPatternsToBeBundled(\n  exp: ExpoConfig & { extra?: { updates?: { assetPatternsToBeBundled?: string[] } } }\n): string[] | undefined {\n  // new location for this key\n  if (exp.updates?.assetPatternsToBeBundled?.length) {\n    return exp.updates.assetPatternsToBeBundled;\n  }\n\n  // old, untyped location for this key. we may want to change this to throw in a few SDK versions (deprecated as of SDK 52).\n  if (exp.extra?.updates?.assetPatternsToBeBundled?.length) {\n    return exp.extra.updates.assetPatternsToBeBundled;\n  }\n\n  return undefined;\n}\n\n/**\n * Given an asset and a set of strings representing the assets to be bundled, returns true if\n * the asset is part of the set to be bundled.\n * @param asset Asset object\n * @param bundledAssetsSet Set of strings\n * @returns true if the asset should be bundled\n */\nfunction assetShouldBeIncludedInExport(asset: Asset, bundledAssetsSet: Set<string> | undefined) {\n  if (!bundledAssetsSet) {\n    return true;\n  }\n  return (\n    asset.fileHashes.filter((hash) => bundledAssetsSet.has(mapAssetHashToAssetString(asset, hash)))\n      .length > 0\n  );\n}\n\n/**\n * Computes a set of strings representing the assets to be bundled with an export, given an array of assets,\n * and a set of patterns to match\n * @param assets The asset array\n * @param assetPatternsToBeBundled An array of strings with glob patterns to match\n * @param projectRoot The project root\n * @returns A set of asset strings\n */\nfunction setOfAssetsToBeBundled(\n  assets: Asset[],\n  assetPatternsToBeBundled: string[],\n  projectRoot: string\n): Set<string> | undefined {\n  // Convert asset patterns to a list of asset strings that match them.\n  // Assets strings are formatted as `asset_<hash>.<type>` and represent\n  // the name that the file will have in the app bundle. The `asset_` prefix is\n  // needed because android doesn't support assets that start with numbers.\n\n  const fullPatterns: string[] = assetPatternsToBeBundled.map((p: string) =>\n    path.join(projectRoot, p)\n  );\n\n  logPatterns(fullPatterns);\n\n  const allBundledAssets = assets\n    .map((asset) => {\n      const shouldBundle = shouldBundleAsset(asset, fullPatterns);\n      if (shouldBundle) {\n        debug(`${shouldBundle ? 'Include' : 'Exclude'} asset ${asset.files?.[0]}`);\n        return asset.fileHashes.map((hash) => mapAssetHashToAssetString(asset, hash));\n      }\n      return [];\n    })\n    .flat();\n\n  // The assets returned by the RN packager has duplicates so make sure we\n  // only bundle each once.\n  return new Set(allBundledAssets);\n}\n\n/**\n * Resolves the assetBundlePatterns from the manifest and returns the set of assets to bundle.\n *\n * @modifies {exp}\n */\nexport function resolveAssetPatternsToBeBundled<T extends ExpoConfig>(\n  projectRoot: string,\n  exp: T,\n  assets: Asset[]\n): Set<string> | undefined {\n  const assetPatternsToBeBundledForConfig = assetPatternsToBeBundled(exp);\n  if (!assetPatternsToBeBundledForConfig) {\n    return undefined;\n  }\n  const bundledAssets = setOfAssetsToBeBundled(\n    assets,\n    assetPatternsToBeBundledForConfig,\n    projectRoot\n  );\n  return bundledAssets;\n}\n\nfunction logPatterns(patterns: string[]) {\n  // Only log the patterns in debug mode, if they aren't already defined in the app.json, then all files will be targeted.\n  Log.log('\\nProcessing asset bundle patterns:');\n  patterns.forEach((p) => Log.log('- ' + p));\n}\n\nfunction shouldBundleAsset(asset: Asset, patterns: string[]) {\n  const file = asset.files?.[0];\n  return !!(\n    '__packager_asset' in asset &&\n    asset.__packager_asset &&\n    file &&\n    patterns.some((pattern) => minimatch(file, pattern))\n  );\n}\n\nexport async function exportAssetsAsync(\n  projectRoot: string,\n  {\n    exp,\n    outputDir,\n    bundles: { web, ...bundles },\n    baseUrl,\n    files = new Map(),\n  }: {\n    exp: ExpoConfig;\n    bundles: Partial<Record<string, BundleOutput>>;\n    outputDir: string;\n    baseUrl: string;\n    files?: ExportAssetMap;\n  }\n) {\n  // NOTE: We use a different system for static web\n  if (web) {\n    // Save assets like a typical bundler, preserving the file paths on web.\n    // TODO: Update React Native Web to support loading files from asset hashes.\n    await persistMetroAssetsAsync(projectRoot, web.assets, {\n      files,\n      platform: 'web',\n      outputDirectory: outputDir,\n      baseUrl,\n    });\n  }\n\n  const assets: BundleAssetWithFileHashes[] = uniqBy(\n    Object.values(bundles).flatMap((bundle) => bundle!.assets),\n    (asset) => asset.hash\n  );\n\n  let bundledAssetsSet: Set<string> | undefined = undefined;\n  let filteredAssets = assets;\n  const embeddedHashSet: Set<string> = new Set();\n\n  if (assets[0]?.fileHashes) {\n    debug(`Assets = ${JSON.stringify(assets, null, 2)}`);\n    // Updates the manifest to reflect additional asset bundling + configs\n    // Get only asset strings for assets we will save\n    bundledAssetsSet = resolveAssetPatternsToBeBundled(projectRoot, exp, assets);\n    if (bundledAssetsSet) {\n      debug(`Bundled assets = ${JSON.stringify([...bundledAssetsSet], null, 2)}`);\n      // Filter asset objects to only ones that include assetPatternsToBeBundled matches\n      filteredAssets = assets.filter((asset) => {\n        const shouldInclude = assetShouldBeIncludedInExport(asset, bundledAssetsSet);\n        if (!shouldInclude) {\n          embeddedHashSet.add(asset.hash);\n        }\n        return shouldInclude;\n      });\n      debug(`Filtered assets count = ${filteredAssets.length}`);\n    }\n\n    const hashes = new Set<string>();\n\n    // Add assets to copy.\n    filteredAssets.forEach((asset) => {\n      const assetId = getAssetIdForLogGrouping(projectRoot, asset);\n\n      asset.files.forEach((fp: string, index: number) => {\n        const hash = asset.fileHashes[index];\n        if (hashes.has(hash)) return;\n        hashes.add(hash);\n        files.set(path.join('assets', hash), {\n          originFilename: path.relative(projectRoot, fp),\n          contents: fs.readFileSync(fp),\n          assetId,\n        });\n      });\n    });\n  }\n\n  // Add google services file if it exists\n  await resolveGoogleServicesFile(projectRoot, exp);\n\n  return { exp, assets, embeddedHashSet, files };\n}\n"],"names":["assetPatternsToBeBundled","exportAssetsAsync","resolveAssetPatternsToBeBundled","debug","require","mapAssetHashToAssetString","asset","hash","type","exp","updates","length","extra","undefined","assetShouldBeIncludedInExport","bundledAssetsSet","fileHashes","filter","has","setOfAssetsToBeBundled","assets","projectRoot","fullPatterns","map","p","path","join","logPatterns","allBundledAssets","shouldBundle","shouldBundleAsset","files","flat","Set","assetPatternsToBeBundledForConfig","bundledAssets","patterns","Log","log","forEach","file","__packager_asset","some","pattern","minimatch","outputDir","bundles","web","baseUrl","Map","persistMetroAssetsAsync","platform","outputDirectory","uniqBy","Object","values","flatMap","bundle","filteredAssets","embeddedHashSet","JSON","stringify","shouldInclude","add","hashes","assetId","getAssetIdForLogGrouping","fp","index","set","originFilename","relative","contents","fs","readFileSync","resolveGoogleServicesFile"],"mappings":"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"}
=======
{"version":3,"sources":["../../../src/export/exportAssets.ts"],"sourcesContent":["import { ExpoConfig } from '@expo/config';\nimport fs from 'fs';\nimport minimatch from 'minimatch';\nimport path from 'path';\n\nimport { persistMetroAssetsAsync } from './persistMetroAssets';\nimport type { Asset, ExportAssetMap, BundleOutput } from './saveAssets';\nimport * as Log from '../log';\nimport { resolveGoogleServicesFile } from '../start/server/middleware/resolveAssets';\nimport { uniqBy } from '../utils/array';\n\nconst debug = require('debug')('expo:export:exportAssets') as typeof console.log;\n\nfunction mapAssetHashToAssetString(asset: Asset, hash: string) {\n  return 'asset_' + hash + ('type' in asset && asset.type ? '.' + asset.type : '');\n}\n\nexport function assetPatternsToBeBundled(\n  exp: ExpoConfig & { extra?: { updates?: { assetPatternsToBeBundled?: string[] } } }\n): string[] | undefined {\n  return exp?.extra?.updates?.assetPatternsToBeBundled?.length\n    ? exp?.extra?.updates?.assetPatternsToBeBundled\n    : undefined;\n}\n\n/**\n * Given an asset and a set of strings representing the assets to be bundled, returns true if\n * the asset is part of the set to be bundled.\n * @param asset Asset object\n * @param bundledAssetsSet Set of strings\n * @returns true if the asset should be bundled\n */\nfunction assetShouldBeIncludedInExport(asset: Asset, bundledAssetsSet: Set<string> | undefined) {\n  if (!bundledAssetsSet) {\n    return true;\n  }\n  return (\n    asset.fileHashes.filter((hash) => bundledAssetsSet.has(mapAssetHashToAssetString(asset, hash)))\n      .length > 0\n  );\n}\n\n/**\n * Computes a set of strings representing the assets to be bundled with an export, given an array of assets,\n * and a set of patterns to match\n * @param assets The asset array\n * @param assetPatternsToBeBundled An array of strings with glob patterns to match\n * @param projectRoot The project root\n * @returns A set of asset strings\n */\nfunction setOfAssetsToBeBundled(\n  assets: Asset[],\n  assetPatternsToBeBundled: string[],\n  projectRoot: string\n): Set<string> | undefined {\n  // Convert asset patterns to a list of asset strings that match them.\n  // Assets strings are formatted as `asset_<hash>.<type>` and represent\n  // the name that the file will have in the app bundle. The `asset_` prefix is\n  // needed because android doesn't support assets that start with numbers.\n\n  const fullPatterns: string[] = assetPatternsToBeBundled.map((p: string) =>\n    path.join(projectRoot, p)\n  );\n\n  logPatterns(fullPatterns);\n\n  const allBundledAssets = assets\n    .map((asset) => {\n      const shouldBundle = shouldBundleAsset(asset, fullPatterns);\n      if (shouldBundle) {\n        debug(`${shouldBundle ? 'Include' : 'Exclude'} asset ${asset.files?.[0]}`);\n        return asset.fileHashes.map((hash) => mapAssetHashToAssetString(asset, hash));\n      }\n      return [];\n    })\n    .flat();\n\n  // The assets returned by the RN packager has duplicates so make sure we\n  // only bundle each once.\n  return new Set(allBundledAssets);\n}\n\n/**\n * Resolves the assetBundlePatterns from the manifest and returns the set of assets to bundle.\n *\n * @modifies {exp}\n */\nexport function resolveAssetPatternsToBeBundled<T extends ExpoConfig>(\n  projectRoot: string,\n  exp: T,\n  assets: Asset[]\n): Set<string> | undefined {\n  if (!assetPatternsToBeBundled(exp)) {\n    return undefined;\n  }\n  const bundledAssets = setOfAssetsToBeBundled(\n    assets,\n    assetPatternsToBeBundled(exp) ?? ['**/*'],\n    projectRoot\n  );\n  return bundledAssets;\n}\n\nfunction logPatterns(patterns: string[]) {\n  // Only log the patterns in debug mode, if they aren't already defined in the app.json, then all files will be targeted.\n  Log.log('\\nProcessing asset bundle patterns:');\n  patterns.forEach((p) => Log.log('- ' + p));\n}\n\nfunction shouldBundleAsset(asset: Asset, patterns: string[]) {\n  const file = asset.files?.[0];\n  return !!(\n    '__packager_asset' in asset &&\n    asset.__packager_asset &&\n    file &&\n    patterns.some((pattern) => minimatch(file, pattern))\n  );\n}\n\nexport async function exportAssetsAsync(\n  projectRoot: string,\n  {\n    exp,\n    outputDir,\n    bundles: { web, ...bundles },\n    baseUrl,\n    files = new Map(),\n  }: {\n    exp: ExpoConfig;\n    bundles: Partial<Record<string, BundleOutput>>;\n    outputDir: string;\n    baseUrl: string;\n    files?: ExportAssetMap;\n  }\n) {\n  // NOTE: We use a different system for static web\n  if (web) {\n    // Save assets like a typical bundler, preserving the file paths on web.\n    // TODO: Update React Native Web to support loading files from asset hashes.\n    await persistMetroAssetsAsync(web.assets, {\n      files,\n      platform: 'web',\n      outputDirectory: outputDir,\n      baseUrl,\n    });\n  }\n\n  const assets: Asset[] = uniqBy(\n    Object.values(bundles).flatMap((bundle) => bundle!.assets),\n    (asset) => asset.hash\n  );\n\n  let bundledAssetsSet: Set<string> | undefined = undefined;\n  let filteredAssets = assets;\n  const embeddedHashSet: Set<string> = new Set();\n\n  if (assets[0]?.fileHashes) {\n    debug(`Assets = ${JSON.stringify(assets, null, 2)}`);\n    // Updates the manifest to reflect additional asset bundling + configs\n    // Get only asset strings for assets we will save\n    bundledAssetsSet = resolveAssetPatternsToBeBundled(projectRoot, exp, assets);\n    if (bundledAssetsSet) {\n      debug(`Bundled assets = ${JSON.stringify([...bundledAssetsSet], null, 2)}`);\n      // Filter asset objects to only ones that include assetPatternsToBeBundled matches\n      filteredAssets = assets.filter((asset) => {\n        const shouldInclude = assetShouldBeIncludedInExport(asset, bundledAssetsSet);\n        if (!shouldInclude) {\n          embeddedHashSet.add(asset.hash);\n        }\n        return shouldInclude;\n      });\n      debug(`Filtered assets count = ${filteredAssets.length}`);\n    }\n\n    const hashes = new Set<string>();\n\n    // Add assets to copy.\n    filteredAssets.forEach((asset) => {\n      const assetId =\n        'fileSystemLocation' in asset\n          ? path.relative(projectRoot, path.join(asset.fileSystemLocation, asset.name)) +\n            (asset.type ? '.' + asset.type : '')\n          : undefined;\n\n      asset.files.forEach((fp: string, index: number) => {\n        const hash = asset.fileHashes[index];\n        if (hashes.has(hash)) return;\n        hashes.add(hash);\n        files.set(path.join('assets', hash), {\n          originFilename: path.relative(projectRoot, fp),\n          contents: fs.readFileSync(fp),\n          assetId,\n        });\n      });\n    });\n  }\n\n  // Add google services file if it exists\n  await resolveGoogleServicesFile(projectRoot, exp);\n\n  return { exp, assets, embeddedHashSet, files };\n}\n"],"names":["assetPatternsToBeBundled","resolveAssetPatternsToBeBundled","exportAssetsAsync","debug","require","mapAssetHashToAssetString","asset","hash","type","exp","extra","updates","length","undefined","assetShouldBeIncludedInExport","bundledAssetsSet","fileHashes","filter","has","setOfAssetsToBeBundled","assets","projectRoot","fullPatterns","map","p","path","join","logPatterns","allBundledAssets","shouldBundle","shouldBundleAsset","files","flat","Set","bundledAssets","patterns","Log","log","forEach","file","__packager_asset","some","pattern","minimatch","outputDir","bundles","web","baseUrl","Map","persistMetroAssetsAsync","platform","outputDirectory","uniqBy","Object","values","flatMap","bundle","filteredAssets","embeddedHashSet","JSON","stringify","shouldInclude","add","hashes","assetId","relative","fileSystemLocation","name","fp","index","set","originFilename","contents","fs","readFileSync","resolveGoogleServicesFile"],"mappings":"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"}
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
