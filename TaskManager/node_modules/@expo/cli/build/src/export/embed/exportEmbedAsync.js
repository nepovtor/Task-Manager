/**
 * Copyright Â© 2023 650 Industries.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
<<<<<<< HEAD
    createMetroServerAndBundleRequestAsync: function() {
        return createMetroServerAndBundleRequestAsync;
    },
    exportEmbedAssetsAsync: function() {
        return exportEmbedAssetsAsync;
    },
    exportEmbedAsync: function() {
        return exportEmbedAsync;
    },
    exportEmbedBundleAndAssetsAsync: function() {
        return exportEmbedBundleAndAssetsAsync;
    },
    exportEmbedInternalAsync: function() {
        return exportEmbedInternalAsync;
    }
=======
    exportEmbedAsync: ()=>exportEmbedAsync,
    exportEmbedBundleAndAssetsAsync: ()=>exportEmbedBundleAndAssetsAsync,
    createMetroServerAndBundleRequestAsync: ()=>createMetroServerAndBundleRequestAsync,
    exportEmbedAssetsAsync: ()=>exportEmbedAssetsAsync
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
});
function _config() {
    const data = require("@expo/config");
    _config = function() {
        return data;
    };
    return data;
}
function _getAssets() {
<<<<<<< HEAD
    const data = /*#__PURE__*/ _interop_require_default(require("@expo/metro-config/build/transform-worker/getAssets"));
=======
    const data = /*#__PURE__*/ _interopRequireDefault(require("@expo/metro-config/build/transform-worker/getAssets"));
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    _getAssets = function() {
        return data;
    };
    return data;
}
function _assert() {
<<<<<<< HEAD
    const data = /*#__PURE__*/ _interop_require_default(require("assert"));
=======
    const data = /*#__PURE__*/ _interopRequireDefault(require("assert"));
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    _assert = function() {
        return data;
    };
    return data;
}
function _fs() {
<<<<<<< HEAD
    const data = /*#__PURE__*/ _interop_require_default(require("fs"));
=======
    const data = /*#__PURE__*/ _interopRequireDefault(require("fs"));
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    _fs = function() {
        return data;
    };
    return data;
}
function _glob() {
    const data = require("glob");
    _glob = function() {
        return data;
    };
    return data;
}
<<<<<<< HEAD
function _Server() {
    const data = /*#__PURE__*/ _interop_require_default(require("metro/src/Server"));
    _Server = function() {
=======
function _server() {
    const data = /*#__PURE__*/ _interopRequireDefault(require("metro/src/Server"));
    _server = function() {
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
        return data;
    };
    return data;
}
function _splitBundleOptions() {
<<<<<<< HEAD
    const data = /*#__PURE__*/ _interop_require_default(require("metro/src/lib/splitBundleOptions"));
=======
    const data = /*#__PURE__*/ _interopRequireDefault(require("metro/src/lib/splitBundleOptions"));
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    _splitBundleOptions = function() {
        return data;
    };
    return data;
}
function _bundle() {
<<<<<<< HEAD
    const data = /*#__PURE__*/ _interop_require_default(require("metro/src/shared/output/bundle"));
=======
    const data = /*#__PURE__*/ _interopRequireDefault(require("metro/src/shared/output/bundle"));
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    _bundle = function() {
        return data;
    };
    return data;
}
function _path() {
<<<<<<< HEAD
    const data = /*#__PURE__*/ _interop_require_default(require("path"));
=======
    const data = /*#__PURE__*/ _interopRequireDefault(require("path"));
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    _path = function() {
        return data;
    };
    return data;
}
<<<<<<< HEAD
const _resolveOptions = require("./resolveOptions");
const _xcodeCompilerLogger = require("./xcodeCompilerLogger");
const _log = require("../../log");
const _DevServerManager = require("../../start/server/DevServerManager");
const _MetroBundlerDevServer = require("../../start/server/metro/MetroBundlerDevServer");
const _instantiateMetro = require("../../start/server/metro/instantiateMetro");
const _metroPrivateServer = require("../../start/server/metro/metroPrivateServer");
const _DomComponentsMiddleware = require("../../start/server/middleware/DomComponentsMiddleware");
const _metroOptions = require("../../start/server/middleware/metroOptions");
const _ansi = require("../../utils/ansi");
const _dir = require("../../utils/dir");
const _env = require("../../utils/env");
const _nodeEnv = require("../../utils/nodeEnv");
const _exportDomComponents = require("../exportDomComponents");
const _exportHermes = require("../exportHermes");
const _persistMetroAssets = require("../persistMetroAssets");
const _publicFolder = require("../publicFolder");
const _saveAssets = require("../saveAssets");
const _exportServer = require("./exportServer");
const _exit = require("../../utils/exit");
const _filePath = require("../../utils/filePath");
function _interop_require_default(obj) {
=======
const _xcodeCompilerLogger = require("./xcodeCompilerLogger");
const _log = require("../../log");
const _devServerManager = require("../../start/server/DevServerManager");
const _metroBundlerDevServer = require("../../start/server/metro/MetroBundlerDevServer");
const _instantiateMetro = require("../../start/server/metro/instantiateMetro");
const _metroPrivateServer = require("../../start/server/metro/metroPrivateServer");
const _metroOptions = require("../../start/server/middleware/metroOptions");
const _ansi = require("../../utils/ansi");
const _dir = require("../../utils/dir");
const _nodeEnv = require("../../utils/nodeEnv");
const _exportHermes = require("../exportHermes");
const _persistMetroAssets = require("../persistMetroAssets");
function _interopRequireDefault(obj) {
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
<<<<<<< HEAD
const debug = require('debug')('expo:export:embed');
function guessCopiedAppleBundlePath(bundleOutput) {
    // Ensure the path is familiar before guessing.
    if (!bundleOutput.match(/\/Xcode\/DerivedData\/.*\/Build\/Products\//) && !bundleOutput.match(/\/CoreSimulator\/Devices\/.*\/data\/Containers\/Bundle\/Application\//)) {
        debug('Bundling to non-standard location:', bundleOutput);
=======
const debug = require("debug")("expo:export:embed");
function guessCopiedAppleBundlePath(bundleOutput) {
    // Ensure the path is familiar before guessing.
    if (!bundleOutput.match(/\/Xcode\/DerivedData\/.*\/Build\/Products\//)) {
        debug("Bundling to non-standard location:", bundleOutput);
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
        return false;
    }
    const bundleName = _path().default.basename(bundleOutput);
    const bundleParent = _path().default.dirname(bundleOutput);
<<<<<<< HEAD
    const possiblePath = (0, _glob().sync)(`*.app/${bundleName}`, {
        cwd: bundleParent,
        absolute: true,
        // bundle identifiers can start with dots.
        dot: true
    })[0];
    debug('Possible path for previous bundle:', possiblePath);
    return possiblePath;
}
async function exportEmbedAsync(projectRoot, options) {
    // The React Native build scripts always enable the cache reset but we shouldn't need this in CI environments.
    // By disabling it, we can eagerly bundle code before the build and reuse the cached artifacts in subsequent builds.
    if (_env.env.CI && options.resetCache) {
        debug('CI environment detected, disabling automatic cache reset');
        options.resetCache = false;
    }
    (0, _nodeEnv.setNodeEnv)(options.dev ? 'development' : 'production');
    require('@expo/env').load(projectRoot);
    // This is an optimized codepath that can occur during `npx expo run` and does not occur during builds from Xcode or Android Studio.
    // Here we reconcile a bundle pass that was run before the native build process. This order can fail faster and is show better errors since the logs won't be obscured by Xcode and Android Studio.
    // This path is also used for automatically deploying server bundles to a remote host.
    const eagerBundleOptions = _env.env.__EXPO_EAGER_BUNDLE_OPTIONS ? (0, _resolveOptions.deserializeEagerKey)(_env.env.__EXPO_EAGER_BUNDLE_OPTIONS) : null;
    if (eagerBundleOptions) {
        // Get the cache key for the current process to compare against the eager key.
        const inputKey = (0, _resolveOptions.getExportEmbedOptionsKey)(options);
        // If the app was bundled previously in the same process, then we should reuse the Metro cache.
        options.resetCache = false;
        if (eagerBundleOptions.key === inputKey) {
            // Copy the eager bundleOutput and assets to the new locations.
            await (0, _dir.removeAsync)(options.bundleOutput);
            (0, _dir.copyAsync)(eagerBundleOptions.options.bundleOutput, options.bundleOutput);
            if (eagerBundleOptions.options.assetsDest && options.assetsDest) {
                (0, _dir.copyAsync)(eagerBundleOptions.options.assetsDest, options.assetsDest);
            }
            console.log('info: Copied output to binary:', options.bundleOutput);
            return;
        }
        // TODO: sourcemapOutput is set on Android but not during eager. This is tolerable since it doesn't invalidate the Metro cache.
        console.log('  Eager key:', eagerBundleOptions.key);
        console.log('Request key:', inputKey);
        // TODO: We may want an analytic event here in the future to understand when this happens.
        console.warn('warning: Eager bundle does not match new options, bundling again.');
    }
    await exportEmbedInternalAsync(projectRoot, options);
    // Ensure the process closes after bundling
    (0, _exit.ensureProcessExitsAfterDelay)();
}
async function exportEmbedInternalAsync(projectRoot, options) {
=======
    const possiblePath = (0, _glob().sync)(_path().default.join(bundleParent, `*.app/${bundleName}`), {
        // bundle identifiers can start with dots.
        dot: true
    })[0];
    debug("Possible path for previous bundle:", possiblePath);
    return possiblePath;
}
async function exportEmbedAsync(projectRoot, options) {
    (0, _nodeEnv.setNodeEnv)(options.dev ? "development" : "production");
    require("@expo/env").load(projectRoot);
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    // Ensure we delete the old bundle to trigger a failure if the bundle cannot be created.
    await (0, _dir.removeAsync)(options.bundleOutput);
    // The iOS bundle is copied in to the Xcode project, so we need to remove the old one
    // to prevent Xcode from loading the old one after a build failure.
<<<<<<< HEAD
    if (options.platform === 'ios') {
        const previousPath = guessCopiedAppleBundlePath(options.bundleOutput);
        if (previousPath && _fs().default.existsSync(previousPath)) {
            debug('Removing previous iOS bundle:', previousPath);
            await (0, _dir.removeAsync)(previousPath);
        }
    }
    const { bundle, assets, files } = await exportEmbedBundleAndAssetsAsync(projectRoot, options);
=======
    if (options.platform === "ios") {
        const previousPath = guessCopiedAppleBundlePath(options.bundleOutput);
        if (previousPath && _fs().default.existsSync(previousPath)) {
            debug("Removing previous iOS bundle:", previousPath);
            await (0, _dir.removeAsync)(previousPath);
        }
    }
    const { bundle , assets  } = await exportEmbedBundleAndAssetsAsync(projectRoot, options);
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    _fs().default.mkdirSync(_path().default.dirname(options.bundleOutput), {
        recursive: true,
        mode: 493
    });
<<<<<<< HEAD
    // On Android, dom components proxy files should write to the assets directory instead of the res directory.
    // We use the bundleOutput directory to get the assets directory.
    const domComponentProxyOutputDir = options.platform === 'android' ? _path().default.dirname(options.bundleOutput) : options.assetsDest;
    const hasDomComponents = domComponentProxyOutputDir && files.size > 0;
    // Persist bundle and source maps.
    await Promise.all([
        // @ts-expect-error: The `save()` method from metro is typed to support `code: string` only but it also supports `Buffer` actually.
        _bundle().default.save(bundle, options, _log.Log.log),
        // Write dom components proxy files.
        hasDomComponents ? (0, _saveAssets.persistMetroFilesAsync)(files, domComponentProxyOutputDir) : null,
        // Copy public folder for dom components only if
        hasDomComponents ? (0, _publicFolder.copyPublicFolderAsync)(_path().default.resolve(projectRoot, _env.env.EXPO_PUBLIC_FOLDER), _path().default.join(domComponentProxyOutputDir, _DomComponentsMiddleware.DOM_COMPONENTS_BUNDLE_DIR)) : null,
        // NOTE(EvanBacon): This may need to be adjusted in the future if want to support baseUrl on native
        // platforms when doing production embeds (unlikely).
        options.assetsDest ? (0, _persistMetroAssets.persistMetroAssetsAsync)(projectRoot, assets, {
            platform: options.platform,
            outputDirectory: options.assetsDest,
            iosAssetCatalogDirectory: options.assetCatalogDest
        }) : null
    ]);
}
async function exportEmbedBundleAndAssetsAsync(projectRoot, options) {
    const devServerManager = await _DevServerManager.DevServerManager.startMetroAsync(projectRoot, {
        minify: options.minify,
        mode: options.dev ? 'development' : 'production',
=======
    // Persist bundle and source maps.
    await Promise.all([
        _bundle().default.save(bundle, options, _log.Log.log),
        // NOTE(EvanBacon): This may need to be adjusted in the future if want to support baseUrl on native
        // platforms when doing production embeds (unlikely).
        options.assetsDest ? (0, _persistMetroAssets.persistMetroAssetsAsync)(assets, {
            platform: options.platform,
            outputDirectory: options.assetsDest,
            iosAssetCatalogDirectory: options.assetCatalogDest
        }) : null, 
    ]);
}
async function exportEmbedBundleAndAssetsAsync(projectRoot, options) {
    const devServerManager = await _devServerManager.DevServerManager.startMetroAsync(projectRoot, {
        minify: options.minify,
        mode: options.dev ? "development" : "production",
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
        port: 8081,
        isExporting: true,
        location: {},
        resetDevServer: options.resetCache,
        maxWorkers: options.maxWorkers
    });
    const devServer = devServerManager.getDefaultDevServer();
<<<<<<< HEAD
    (0, _assert().default)(devServer instanceof _MetroBundlerDevServer.MetroBundlerDevServer);
    const { exp, pkg } = (0, _config().getConfig)(projectRoot, {
        skipSDKVersionRequirement: true
    });
=======
    (0, _assert().default)(devServer instanceof _metroBundlerDevServer.MetroBundlerDevServer);
    const exp = (0, _config().getConfig)(projectRoot, {
        skipSDKVersionRequirement: true
    }).exp;
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    const isHermes = (0, _exportHermes.isEnableHermesManaged)(exp, options.platform);
    let sourceMapUrl = options.sourcemapOutput;
    if (sourceMapUrl && !options.sourcemapUseAbsolutePath) {
        sourceMapUrl = _path().default.basename(sourceMapUrl);
    }
<<<<<<< HEAD
    const files = new Map();
    try {
        var _exp_experiments, _exp_web, _bundles_artifacts_filter_;
        const bundles = await devServer.nativeExportBundleAsync(exp, {
            // TODO: Re-enable when we get bytecode chunk splitting working again.
            splitChunks: false,
            mainModuleName: (0, _filePath.resolveRealEntryFilePath)(projectRoot, options.entryFile),
            platform: options.platform,
            minify: options.minify,
            mode: options.dev ? 'development' : 'production',
            engine: isHermes ? 'hermes' : undefined,
            serializerIncludeMaps: !!sourceMapUrl,
            bytecode: options.bytecode ?? false,
            // source map inline
            reactCompiler: !!((_exp_experiments = exp.experiments) == null ? void 0 : _exp_experiments.reactCompiler)
        }, files, {
            sourceMapUrl,
            unstable_transformProfile: options.unstableTransformProfile || (isHermes ? 'hermes-stable' : 'default')
        });
        const apiRoutesEnabled = devServer.isReactServerComponentsEnabled || ((_exp_web = exp.web) == null ? void 0 : _exp_web.output) === 'server';
        if (apiRoutesEnabled) {
            await (0, _exportServer.exportStandaloneServerAsync)(projectRoot, devServer, {
                exp,
                pkg,
                files,
                options
            });
        }
        // TODO: Remove duplicates...
        const expoDomComponentReferences = bundles.artifacts.map((artifact)=>Array.isArray(artifact.metadata.expoDomComponentReferences) ? artifact.metadata.expoDomComponentReferences : []).flat();
        if (expoDomComponentReferences.length > 0) {
            await Promise.all(// TODO: Make a version of this which uses `this.metro.getBundler().buildGraphForEntries([])` to bundle all the DOM components at once.
            expoDomComponentReferences.map(async (filePath)=>{
                const { bundle } = await (0, _exportDomComponents.exportDomComponentAsync)({
                    filePath,
                    projectRoot,
                    dev: options.dev,
                    devServer,
                    isHermes,
                    includeSourceMaps: !!sourceMapUrl,
                    exp,
                    files
                });
                if (options.assetsDest) {
                    // Save assets like a typical bundler, preserving the file paths on web.
                    // This is saving web-style inside of a native app's binary.
                    await (0, _persistMetroAssets.persistMetroAssetsAsync)(projectRoot, bundle.assets.map((asset)=>({
                            ...asset,
                            httpServerLocation: _path().default.join(_DomComponentsMiddleware.DOM_COMPONENTS_BUNDLE_DIR, asset.httpServerLocation)
                        })), {
                        files,
                        platform: 'web',
                        outputDirectory: options.assetsDest
                    });
                }
            }));
        }
        return {
            files,
            bundle: {
                code: bundles.artifacts.filter((a)=>a.type === 'js')[0].source,
                // Can be optional when source maps aren't enabled.
                map: (_bundles_artifacts_filter_ = bundles.artifacts.filter((a)=>a.type === 'map')[0]) == null ? void 0 : _bundles_artifacts_filter_.source.toString()
=======
    try {
        var ref, ref1;
        const bundles = await devServer.legacySinglePageExportBundleAsync({
            splitChunks: false,
            mainModuleName: resolveRealEntryFilePath(projectRoot, options.entryFile),
            platform: options.platform,
            minify: options.minify,
            mode: options.dev ? "development" : "production",
            engine: isHermes ? "hermes" : undefined,
            serializerIncludeMaps: !!sourceMapUrl,
            // Never output bytecode in the exported bundle since that is hardcoded in the native run script.
            bytecode: false,
            // source map inline
            reactCompiler: !!((ref = exp.experiments) == null ? void 0 : ref.reactCompiler)
        }, {
            sourceMapUrl,
            unstable_transformProfile: options.unstableTransformProfile || (isHermes ? "hermes-stable" : "default")
        });
        return {
            bundle: {
                code: bundles.artifacts.filter((a)=>a.type === "js")[0].source.toString(),
                // Can be optional when source maps aren't enabled.
                map: (ref1 = bundles.artifacts.filter((a)=>a.type === "map")[0]) == null ? void 0 : ref1.source.toString()
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
            },
            assets: bundles.assets
        };
    } catch (error) {
        if (isError(error)) {
            // Log using Xcode error format so the errors are picked up by xcodebuild.
            // https://developer.apple.com/documentation/xcode/running-custom-scripts-during-a-build#Log-errors-and-warnings-from-your-script
<<<<<<< HEAD
            if (options.platform === 'ios') {
                // If the error is about to be presented in Xcode, strip the ansi characters from the message.
                if ('message' in error && (0, _xcodeCompilerLogger.isExecutingFromXcodebuild)()) {
=======
            if (options.platform === "ios") {
                // If the error is about to be presented in Xcode, strip the ansi characters from the message.
                if ("message" in error && (0, _xcodeCompilerLogger.isExecutingFromXcodebuild)()) {
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
                    error.message = (0, _ansi.stripAnsi)(error.message);
                }
                (0, _xcodeCompilerLogger.logMetroErrorInXcode)(projectRoot, error);
            }
        }
        throw error;
    } finally{
        devServerManager.stopAsync();
    }
}
async function createMetroServerAndBundleRequestAsync(projectRoot, options) {
    const exp = (0, _config().getConfig)(projectRoot, {
        skipSDKVersionRequirement: true
    }).exp;
    // TODO: This is slow ~40ms
<<<<<<< HEAD
    const { config } = await (0, _instantiateMetro.loadMetroConfigAsync)(projectRoot, {
=======
    const { config  } = await (0, _instantiateMetro.loadMetroConfigAsync)(projectRoot, {
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
        // TODO: This is always enabled in the native script and there's no way to disable it.
        resetCache: options.resetCache,
        maxWorkers: options.maxWorkers,
        config: options.config
    }, {
        exp,
        isExporting: true,
        getMetroBundler () {
            return server.getBundler().getBundler();
        }
    });
    const isHermes = (0, _exportHermes.isEnableHermesManaged)(exp, options.platform);
    let sourceMapUrl = options.sourcemapOutput;
    if (sourceMapUrl && !options.sourcemapUseAbsolutePath) {
        sourceMapUrl = _path().default.basename(sourceMapUrl);
    }
<<<<<<< HEAD
    // TODO(cedric): check if we can use the proper `bundleType=bundle` and `entryPoint=mainModuleName` properties
    // @ts-expect-error: see above
    const bundleRequest = {
        ..._Server().default.DEFAULT_BUNDLE_OPTIONS,
        ...(0, _metroOptions.getMetroDirectBundleOptionsForExpoConfig)(projectRoot, exp, {
            splitChunks: false,
            mainModuleName: (0, _filePath.resolveRealEntryFilePath)(projectRoot, options.entryFile),
            platform: options.platform,
            minify: options.minify,
            mode: options.dev ? 'development' : 'production',
            engine: isHermes ? 'hermes' : undefined,
=======
    const bundleRequest = {
        ..._server().default.DEFAULT_BUNDLE_OPTIONS,
        ...(0, _metroOptions.getMetroDirectBundleOptionsForExpoConfig)(projectRoot, exp, {
            splitChunks: false,
            mainModuleName: resolveRealEntryFilePath(projectRoot, options.entryFile),
            platform: options.platform,
            minify: options.minify,
            mode: options.dev ? "development" : "production",
            engine: isHermes ? "hermes" : undefined,
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
            isExporting: true,
            // Never output bytecode in the exported bundle since that is hardcoded in the native run script.
            bytecode: false
        }),
        sourceMapUrl,
<<<<<<< HEAD
        unstable_transformProfile: options.unstableTransformProfile || (isHermes ? 'hermes-stable' : 'default')
    };
    const server = new (_Server()).default(config, {
=======
        unstable_transformProfile: options.unstableTransformProfile || (isHermes ? "hermes-stable" : "default")
    };
    const server = new (_server()).default(config, {
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
        watch: false
    });
    return {
        server,
        bundleRequest
    };
}
async function exportEmbedAssetsAsync(server, bundleRequest, projectRoot, options) {
    try {
<<<<<<< HEAD
        const { entryFile, onProgress, resolverOptions, transformOptions } = (0, _splitBundleOptions().default)({
            ...bundleRequest,
            bundleType: 'todo'
=======
        const { entryFile , onProgress , resolverOptions , transformOptions  } = (0, _splitBundleOptions().default)({
            ...bundleRequest,
            bundleType: "todo"
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
        });
        (0, _metroPrivateServer.assertMetroPrivateServer)(server);
        const dependencies = await server._bundler.getDependencies([
            entryFile
        ], transformOptions, resolverOptions, {
            onProgress,
            shallow: false,
            lazy: false
        });
        const config = server._config;
        return (0, _getAssets().default)(dependencies, {
            processModuleFilter: config.serializer.processModuleFilter,
            assetPlugins: config.transformer.assetPlugins,
            platform: transformOptions.platform,
            // Forked out of Metro because the `this._getServerRootDir()` doesn't match the development
            // behavior.
            projectRoot: config.projectRoot,
            publicPath: config.transformer.publicPath
        });
    } catch (error) {
        if (isError(error)) {
            // Log using Xcode error format so the errors are picked up by xcodebuild.
            // https://developer.apple.com/documentation/xcode/running-custom-scripts-during-a-build#Log-errors-and-warnings-from-your-script
<<<<<<< HEAD
            if (options.platform === 'ios') {
                // If the error is about to be presented in Xcode, strip the ansi characters from the message.
                if ('message' in error && (0, _xcodeCompilerLogger.isExecutingFromXcodebuild)()) {
=======
            if (options.platform === "ios") {
                // If the error is about to be presented in Xcode, strip the ansi characters from the message.
                if ("message" in error && (0, _xcodeCompilerLogger.isExecutingFromXcodebuild)()) {
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
                    error.message = (0, _ansi.stripAnsi)(error.message);
                }
                (0, _xcodeCompilerLogger.logMetroErrorInXcode)(projectRoot, error);
            }
        }
        throw error;
    }
}
function isError(error) {
    return error instanceof Error;
}
<<<<<<< HEAD
=======
/**
 * This is a workaround for Metro not resolving entry file paths to their real location.
 * When running exports through `eas build --local` on macOS, the `/var/folders` path is used instead of `/private/var/folders`.
 *
 * See: https://github.com/expo/expo/issues/28890
 */ function resolveRealEntryFilePath(projectRoot, entryFile) {
    if (projectRoot.startsWith("/private/var") && entryFile.startsWith("/var")) {
        return _fs().default.realpathSync(entryFile);
    }
    return entryFile;
}
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251

//# sourceMappingURL=exportEmbedAsync.js.map