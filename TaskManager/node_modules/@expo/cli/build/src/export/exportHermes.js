"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
<<<<<<< HEAD
    assertEngineMismatchAsync: function() {
        return assertEngineMismatchAsync;
    },
    getHermesBytecodeBundleVersionAsync: function() {
        return getHermesBytecodeBundleVersionAsync;
    },
    isAndroidUsingHermes: function() {
        return isAndroidUsingHermes;
    },
    isEnableHermesManaged: function() {
        return isEnableHermesManaged;
    },
    isHermesBytecodeBundleAsync: function() {
        return isHermesBytecodeBundleAsync;
    },
    isHermesPossiblyEnabled: function() {
        return isHermesPossiblyEnabled;
    },
    isIosUsingHermes: function() {
        return isIosUsingHermes;
    },
    maybeInconsistentEngineAndroidAsync: function() {
        return maybeInconsistentEngineAndroidAsync;
    },
    maybeInconsistentEngineIosAsync: function() {
        return maybeInconsistentEngineIosAsync;
    },
    maybeThrowFromInconsistentEngineAsync: function() {
        return maybeThrowFromInconsistentEngineAsync;
    },
    parseGradleProperties: function() {
        return parseGradleProperties;
    }
=======
    assertEngineMismatchAsync: ()=>assertEngineMismatchAsync,
    isEnableHermesManaged: ()=>isEnableHermesManaged,
    parseGradleProperties: ()=>parseGradleProperties,
    maybeThrowFromInconsistentEngineAsync: ()=>maybeThrowFromInconsistentEngineAsync,
    maybeInconsistentEngineAndroidAsync: ()=>maybeInconsistentEngineAndroidAsync,
    maybeInconsistentEngineIosAsync: ()=>maybeInconsistentEngineIosAsync,
    isHermesBytecodeBundleAsync: ()=>isHermesBytecodeBundleAsync,
    getHermesBytecodeBundleVersionAsync: ()=>getHermesBytecodeBundleVersionAsync
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
});
function _config() {
    const data = require("@expo/config");
    _config = function() {
        return data;
    };
    return data;
}
<<<<<<< HEAD
function _jsonfile() {
    const data = /*#__PURE__*/ _interop_require_default(require("@expo/json-file"));
    _jsonfile = function() {
        return data;
    };
    return data;
}
function _fs() {
    const data = /*#__PURE__*/ _interop_require_default(require("fs"));
    _fs = function() {
=======
function _fsExtra() {
    const data = /*#__PURE__*/ _interopRequireDefault(require("fs-extra"));
    _fsExtra = function() {
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
        return data;
    };
    return data;
}
function _path() {
<<<<<<< HEAD
    const data = /*#__PURE__*/ _interop_require_default(require("path"));
=======
    const data = /*#__PURE__*/ _interopRequireDefault(require("path"));
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    _path = function() {
        return data;
    };
    return data;
}
<<<<<<< HEAD
function _interop_require_default(obj) {
=======
function _interopRequireDefault(obj) {
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
async function assertEngineMismatchAsync(projectRoot, exp, platform) {
    const isHermesManaged = isEnableHermesManaged(exp, platform);
    const paths = (0, _config().getConfigFilePaths)(projectRoot);
<<<<<<< HEAD
    const configFilePath = paths.dynamicConfigPath ?? paths.staticConfigPath ?? 'app.json';
=======
    var _dynamicConfigPath, ref;
    const configFilePath = (ref = (_dynamicConfigPath = paths.dynamicConfigPath) != null ? _dynamicConfigPath : paths.staticConfigPath) != null ? ref : "app.json";
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    await maybeThrowFromInconsistentEngineAsync(projectRoot, configFilePath, platform, isHermesManaged);
}
function isEnableHermesManaged(expoConfig, platform) {
    switch(platform){
<<<<<<< HEAD
        case 'android':
            {
                var _expoConfig_android;
                return (((_expoConfig_android = expoConfig.android) == null ? void 0 : _expoConfig_android.jsEngine) ?? expoConfig.jsEngine) !== 'jsc';
            }
        case 'ios':
            {
                var _expoConfig_ios;
                return (((_expoConfig_ios = expoConfig.ios) == null ? void 0 : _expoConfig_ios.jsEngine) ?? expoConfig.jsEngine) !== 'jsc';
=======
        case "android":
            {
                var ref;
                var ref1;
                return ((ref1 = (ref = expoConfig.android) == null ? void 0 : ref.jsEngine) != null ? ref1 : expoConfig.jsEngine) !== "jsc";
            }
        case "ios":
            {
                var ref2;
                var ref3;
                return ((ref3 = (ref2 = expoConfig.ios) == null ? void 0 : ref2.jsEngine) != null ? ref3 : expoConfig.jsEngine) !== "jsc";
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
            }
        default:
            return false;
    }
}
function parseGradleProperties(content) {
    const result = {};
<<<<<<< HEAD
    for (let line of content.split('\n')){
        line = line.trim();
        if (!line || line.startsWith('#')) {
            continue;
        }
        const sepIndex = line.indexOf('=');
        const key = line.slice(0, sepIndex);
        const value = line.slice(sepIndex + 1);
=======
    for (let line of content.split("\n")){
        line = line.trim();
        if (!line || line.startsWith("#")) {
            continue;
        }
        const sepIndex = line.indexOf("=");
        const key = line.substr(0, sepIndex);
        const value = line.substr(sepIndex + 1);
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
        result[key] = value;
    }
    return result;
}
async function maybeThrowFromInconsistentEngineAsync(projectRoot, configFilePath, platform, isHermesManaged) {
    const configFileName = _path().default.basename(configFilePath);
<<<<<<< HEAD
    if (platform === 'android' && await maybeInconsistentEngineAndroidAsync(projectRoot, isHermesManaged)) {
        throw new Error(`JavaScript engine configuration is inconsistent between ${configFileName} and Android native project.\n` + `In ${configFileName}: Hermes is ${isHermesManaged ? 'enabled' : 'not enabled'}\n` + `In Android native project: Hermes is ${isHermesManaged ? 'not enabled' : 'enabled'}\n` + `Check the following files for inconsistencies:\n` + `  - ${configFilePath}\n` + `  - ${_path().default.join(projectRoot, 'android', 'gradle.properties')}\n` + `  - ${_path().default.join(projectRoot, 'android', 'app', 'build.gradle')}\n` + 'Learn more: https://expo.fyi/hermes-android-config');
    }
    if (platform === 'ios' && await maybeInconsistentEngineIosAsync(projectRoot, isHermesManaged)) {
        throw new Error(`JavaScript engine configuration is inconsistent between ${configFileName} and iOS native project.\n` + `In ${configFileName}: Hermes is ${isHermesManaged ? 'enabled' : 'not enabled'}\n` + `In iOS native project: Hermes is ${isHermesManaged ? 'not enabled' : 'enabled'}\n` + `Check the following files for inconsistencies:\n` + `  - ${configFilePath}\n` + `  - ${_path().default.join(projectRoot, 'ios', 'Podfile')}\n` + `  - ${_path().default.join(projectRoot, 'ios', 'Podfile.properties.json')}\n` + 'Learn more: https://expo.fyi/hermes-ios-config');
=======
    if (platform === "android" && await maybeInconsistentEngineAndroidAsync(projectRoot, isHermesManaged)) {
        throw new Error(`JavaScript engine configuration is inconsistent between ${configFileName} and Android native project.\n` + `In ${configFileName}: Hermes is ${isHermesManaged ? "enabled" : "not enabled"}\n` + `In Android native project: Hermes is ${isHermesManaged ? "not enabled" : "enabled"}\n` + `Please check the following files for inconsistencies:\n` + `  - ${configFilePath}\n` + `  - ${_path().default.join(projectRoot, "android", "gradle.properties")}\n` + `  - ${_path().default.join(projectRoot, "android", "app", "build.gradle")}\n` + "Learn more: https://expo.fyi/hermes-android-config");
    }
    if (platform === "ios" && await maybeInconsistentEngineIosAsync(projectRoot, isHermesManaged)) {
        throw new Error(`JavaScript engine configuration is inconsistent between ${configFileName} and iOS native project.\n` + `In ${configFileName}: Hermes is ${isHermesManaged ? "enabled" : "not enabled"}\n` + `In iOS native project: Hermes is ${isHermesManaged ? "not enabled" : "enabled"}\n` + `Please check the following files for inconsistencies:\n` + `  - ${configFilePath}\n` + `  - ${_path().default.join(projectRoot, "ios", "Podfile")}\n` + `  - ${_path().default.join(projectRoot, "ios", "Podfile.properties.json")}\n` + "Learn more: https://expo.fyi/hermes-ios-config");
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    }
}
async function maybeInconsistentEngineAndroidAsync(projectRoot, isHermesManaged) {
    // Trying best to check android native project if by chance to be consistent between app config
    // Check gradle.properties from prebuild template
<<<<<<< HEAD
    const gradlePropertiesPath = _path().default.join(projectRoot, 'android', 'gradle.properties');
    if (_fs().default.existsSync(gradlePropertiesPath)) {
        const props = parseGradleProperties(await _fs().default.promises.readFile(gradlePropertiesPath, 'utf8'));
        const isHermesBare = props['hermesEnabled'] === 'true';
=======
    const gradlePropertiesPath = _path().default.join(projectRoot, "android", "gradle.properties");
    if (_fsExtra().default.existsSync(gradlePropertiesPath)) {
        const props = parseGradleProperties(await _fsExtra().default.readFile(gradlePropertiesPath, "utf8"));
        const isHermesBare = props["hermesEnabled"] === "true";
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
        if (isHermesManaged !== isHermesBare) {
            return true;
        }
    }
    return false;
}
<<<<<<< HEAD
function isHermesPossiblyEnabled(projectRoot) {
    // Trying best to check ios native project if by chance to be consistent between app config
    // Check ios/Podfile for ":hermes_enabled => true"
    const podfilePath = _path().default.join(projectRoot, 'ios', 'Podfile');
    if (_fs().default.existsSync(podfilePath)) {
        const content = _fs().default.readFileSync(podfilePath, 'utf8');
        const isPropsReference = content.search(/^\s*:hermes_enabled\s*=>\s*podfile_properties\['expo.jsEngine'\]\s*==\s*nil\s*\|\|\s*podfile_properties\['expo.jsEngine'\]\s*==\s*'hermes',?/m) >= 0;
        const isHermesBare = content.search(/^\s*:hermes_enabled\s*=>\s*true,?\s+/m) >= 0;
        if (!isPropsReference && isHermesBare) {
            return true;
        }
    }
    // Check Podfile.properties.json from prebuild template
    const podfilePropertiesPath = _path().default.join(projectRoot, 'ios', 'Podfile.properties.json');
    if (_fs().default.existsSync(podfilePropertiesPath)) {
        try {
            const props = _jsonfile().default.read(podfilePropertiesPath);
            return props['expo.jsEngine'] === 'hermes';
        } catch  {
        // ignore
        }
    }
    return null;
}
async function maybeInconsistentEngineIosAsync(projectRoot, isHermesManaged) {
    // Trying best to check ios native project if by chance to be consistent between app config
    // Check ios/Podfile for ":hermes_enabled => true"
    const podfilePath = _path().default.join(projectRoot, 'ios', 'Podfile');
    if (_fs().default.existsSync(podfilePath)) {
        const content = await _fs().default.promises.readFile(podfilePath, 'utf8');
=======
async function maybeInconsistentEngineIosAsync(projectRoot, isHermesManaged) {
    // Trying best to check ios native project if by chance to be consistent between app config
    // Check ios/Podfile for ":hermes_enabled => true"
    const podfilePath = _path().default.join(projectRoot, "ios", "Podfile");
    if (_fsExtra().default.existsSync(podfilePath)) {
        const content = await _fsExtra().default.readFile(podfilePath, "utf8");
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
        const isPropsReference = content.search(/^\s*:hermes_enabled\s*=>\s*podfile_properties\['expo.jsEngine'\]\s*==\s*nil\s*\|\|\s*podfile_properties\['expo.jsEngine'\]\s*==\s*'hermes',?/m) >= 0;
        const isHermesBare = content.search(/^\s*:hermes_enabled\s*=>\s*true,?\s+/m) >= 0;
        if (!isPropsReference && isHermesManaged !== isHermesBare) {
            return true;
        }
    }
    // Check Podfile.properties.json from prebuild template
<<<<<<< HEAD
    const podfilePropertiesPath = _path().default.join(projectRoot, 'ios', 'Podfile.properties.json');
    if (_fs().default.existsSync(podfilePropertiesPath)) {
        const props = await parsePodfilePropertiesAsync(podfilePropertiesPath);
        const isHermesBare = props['expo.jsEngine'] === 'hermes';
        if (isHermesManaged !== isHermesBare) {
=======
    const podfilePropertiesPath = _path().default.join(projectRoot, "ios", "Podfile.properties.json");
    if (_fsExtra().default.existsSync(podfilePropertiesPath)) {
        const props = await parsePodfilePropertiesAsync(podfilePropertiesPath);
        const isHermesBare1 = props["expo.jsEngine"] === "hermes";
        if (isHermesManaged !== isHermesBare1) {
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
            return true;
        }
    }
    return false;
}
// https://github.com/facebook/hermes/blob/release-v0.5/include/hermes/BCGen/HBC/BytecodeFileFormat.h#L24-L25
<<<<<<< HEAD
const HERMES_MAGIC_HEADER = 'c61fbc03c103191f';
async function isHermesBytecodeBundleAsync(file) {
    const header = await readHermesHeaderAsync(file);
    return header.subarray(0, 8).toString('hex') === HERMES_MAGIC_HEADER;
}
async function getHermesBytecodeBundleVersionAsync(file) {
    const header = await readHermesHeaderAsync(file);
    if (header.subarray(0, 8).toString('hex') !== HERMES_MAGIC_HEADER) {
        throw new Error('Invalid hermes bundle file');
=======
const HERMES_MAGIC_HEADER = "c61fbc03c103191f";
async function isHermesBytecodeBundleAsync(file) {
    const header = await readHermesHeaderAsync(file);
    return header.slice(0, 8).toString("hex") === HERMES_MAGIC_HEADER;
}
async function getHermesBytecodeBundleVersionAsync(file) {
    const header = await readHermesHeaderAsync(file);
    if (header.slice(0, 8).toString("hex") !== HERMES_MAGIC_HEADER) {
        throw new Error("Invalid hermes bundle file");
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    }
    return header.readUInt32LE(8);
}
async function readHermesHeaderAsync(file) {
<<<<<<< HEAD
    const fd = await _fs().default.promises.open(file, 'r');
    const buffer = Buffer.alloc(12);
    await fd.read(buffer, 0, 12, null);
    await fd.close();
=======
    const fd = await _fsExtra().default.open(file, "r");
    const buffer = Buffer.alloc(12);
    await _fsExtra().default.read(fd, buffer, 0, 12, null);
    await _fsExtra().default.close(fd);
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    return buffer;
}
async function parsePodfilePropertiesAsync(podfilePropertiesPath) {
    try {
<<<<<<< HEAD
        return JSON.parse(await _fs().default.promises.readFile(podfilePropertiesPath, 'utf8'));
=======
        return JSON.parse(await _fsExtra().default.readFile(podfilePropertiesPath, "utf8"));
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    } catch  {
        return {};
    }
}
<<<<<<< HEAD
function isAndroidUsingHermes(projectRoot) {
    // Check gradle.properties from prebuild template
    const gradlePropertiesPath = _path().default.join(projectRoot, 'android', 'gradle.properties');
    if (_fs().default.existsSync(gradlePropertiesPath)) {
        const props = parseGradleProperties(_fs().default.readFileSync(gradlePropertiesPath, 'utf8'));
        return props['hermesEnabled'] === 'true';
    }
    // Assume Hermes is used by default.
    return true;
}
function isIosUsingHermes(projectRoot) {
    // If nullish, then assume Hermes is used.
    return isHermesPossiblyEnabled(projectRoot) !== false;
}
=======
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251

//# sourceMappingURL=exportHermes.js.map