package expo.modules.kotlin.functions

<<<<<<< HEAD
import android.view.View
import expo.modules.BuildConfig
import expo.modules.kotlin.AppContext
import expo.modules.kotlin.Promise
import expo.modules.kotlin.exception.FunctionCallException
import expo.modules.kotlin.exception.exceptionDecorator
import expo.modules.kotlin.exception.toCodedException
import expo.modules.kotlin.jni.decorators.JSDecoratorsBridgingObject
import expo.modules.kotlin.types.AnyType
import expo.modules.kotlin.weak
import kotlinx.coroutines.launch

/**
 * Base class of async function components that require a promise to be called.
 */
abstract class AsyncFunctionComponent(
  name: String,
  desiredArgsTypes: Array<AnyType>
) : BaseAsyncFunctionComponent(name, desiredArgsTypes) {
  internal abstract fun callUserImplementation(args: Array<Any?>, promise: Promise, appContext: AppContext)

  override fun attachToJSObject(appContext: AppContext, jsObject: JSDecoratorsBridgingObject, moduleName: String) {
    val appContextHolder = appContext.weak()
    jsObject.registerAsyncFunction(
      name,
      takesOwner,
      isEnumerable,
      desiredArgsTypes.map { it.getCppRequiredTypes() }.toTypedArray()
    ) { args, promiseImpl ->
      if (BuildConfig.DEBUG) {
        promiseImpl.decorateWithDebugInformation(
          appContextHolder,
          moduleName,
          name
        )
      }

      val functionBody = {
        try {
          exceptionDecorator({
            FunctionCallException(name, moduleName, it)
          }) {
            callUserImplementation(args, promiseImpl, appContext)
          }
        } catch (e: Throwable) {
          // The promise was resolved, so we should rethrow the error.
          if (promiseImpl.wasSettled) {
            throw e
          }
          promiseImpl.reject(e.toCodedException())
        }
      }

      dispatchOnQueue(appContext, functionBody)
    }
  }

  private fun dispatchOnQueue(appContext: AppContext, block: () -> Unit) {
    when (val queue = queue) {
      Queues.DEFAULT -> {
        appContext.modulesQueue.launch {
          block()
        }
      }

      Queues.MAIN -> {
        if (!BuildConfig.IS_NEW_ARCHITECTURE_ENABLED && desiredArgsTypes.any { it.inheritFrom<View>() }) {
          // On certain occasions, invoking a function on a view could lead to an error
          // because of the asynchronous communication between the JavaScript and native components.
          // In such cases, the native view may not have been mounted yet,
          // but the JavaScript code has already received the future tag of the view.
          // To avoid this issue, we have decided to temporarily utilize
          // the UIManagerModule for dispatching functions on the main thread.
          appContext.dispatchOnMainUsingUIManager(block)
          return
        }

        appContext.mainQueue.launch {
          block()
        }
      }

      is CustomQueue ->
        queue.scope.launch {
          block()
        }
    }
=======
import com.facebook.react.bridge.ReadableArray
import expo.modules.kotlin.AppContext
import expo.modules.kotlin.Promise
import expo.modules.kotlin.exception.CodedException
import expo.modules.kotlin.types.AnyType
import expo.modules.kotlin.types.enforceType

inline fun <reified T> createAsyncFunctionComponent(
  name: String,
  desiredArgsTypes: Array<AnyType>,
  noinline body: (args: Array<out Any?>) -> T
): AsyncFunction {
  if (null is T) {
    return AsyncFunctionComponent<Any?>(name, desiredArgsTypes, body)
  }
  return when (T::class.java) {
    Int::class.java -> {
      enforceType<(Array<out Any?>) -> Int>(body)
      IntAsyncFunctionComponent(name, desiredArgsTypes, body)
    }
    Boolean::class.java -> {
      enforceType<(Array<out Any?>) -> Boolean>(body)
      BoolAsyncFunctionComponent(name, desiredArgsTypes, body)
    }
    Double::class.java -> {
      enforceType<(Array<out Any?>) -> Double>(body)
      DoubleAsyncFunctionComponent(name, desiredArgsTypes, body)
    }
    Float::class.java -> {
      enforceType<(Array<out Any?>) -> Float>(body)
      FloatAsyncFunctionComponent(name, desiredArgsTypes, body)
    }
    String::class.java -> {
      enforceType<(Array<out Any?>) -> String>(body)
      StringAsyncFunctionComponent(name, desiredArgsTypes, body)
    }
    else -> AsyncFunctionComponent<Any?>(name, desiredArgsTypes, body)
  }
}

class IntAsyncFunctionComponent(name: String, desiredArgsTypes: Array<AnyType>, body: (args: Array<out Any?>) -> Int) :
  AsyncFunctionComponent<Int>(name, desiredArgsTypes, body) {
  override fun callUserImplementation(args: Array<Any?>, promise: Promise, appContext: AppContext) {
    promise.resolve(body(convertArgs(args, appContext)))
  }
}

class BoolAsyncFunctionComponent(name: String, desiredArgsTypes: Array<AnyType>, body: (args: Array<out Any?>) -> Boolean) :
  AsyncFunctionComponent<Boolean>(name, desiredArgsTypes, body) {
  override fun callUserImplementation(args: Array<Any?>, promise: Promise, appContext: AppContext) {
    promise.resolve(body(convertArgs(args, appContext)))
  }
}

class DoubleAsyncFunctionComponent(name: String, desiredArgsTypes: Array<AnyType>, body: (args: Array<out Any?>) -> Double) :
  AsyncFunctionComponent<Double>(name, desiredArgsTypes, body) {
  override fun callUserImplementation(args: Array<Any?>, promise: Promise, appContext: AppContext) {
    promise.resolve(body(convertArgs(args, appContext)))
  }
}

class FloatAsyncFunctionComponent(name: String, desiredArgsTypes: Array<AnyType>, body: (args: Array<out Any?>) -> Float) :
  AsyncFunctionComponent<Float>(name, desiredArgsTypes, body) {
  override fun callUserImplementation(args: Array<Any?>, promise: Promise, appContext: AppContext) {
    promise.resolve(body(convertArgs(args, appContext)))
  }
}

class StringAsyncFunctionComponent(name: String, desiredArgsTypes: Array<AnyType>, body: (args: Array<out Any?>) -> String) :
  AsyncFunctionComponent<String>(name, desiredArgsTypes, body) {
  override fun callUserImplementation(args: Array<Any?>, promise: Promise, appContext: AppContext) {
    promise.resolve(body(convertArgs(args, appContext)))
  }
}

open class AsyncFunctionComponent<ReturnType>(
  name: String,
  desiredArgsTypes: Array<AnyType>,
  protected val body: (args: Array<out Any?>) -> ReturnType
) : AsyncFunction(name, desiredArgsTypes) {
  @Throws(CodedException::class)
  override fun callUserImplementation(args: ReadableArray, promise: Promise) {
    promise.resolve(body(convertArgs(args)))
  }

  override fun callUserImplementation(args: Array<Any?>, promise: Promise, appContext: AppContext) {
    promise.resolve(body(convertArgs(args, appContext)))
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
  }
}
