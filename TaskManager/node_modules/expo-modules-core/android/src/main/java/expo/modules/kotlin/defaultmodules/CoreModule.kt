package expo.modules.kotlin.defaultmodules

<<<<<<< HEAD
import android.content.Context
import android.net.Uri
import com.facebook.react.ReactActivity
import expo.modules.BuildConfig
import expo.modules.kotlin.events.normalizeEventName
import expo.modules.kotlin.exception.Exceptions
import expo.modules.kotlin.modules.DEFAULT_MODULE_VIEW
=======
import com.facebook.react.ReactActivity
import com.facebook.react.ReactDelegate
import com.facebook.react.bridge.UiThreadUtil
import com.facebook.react.config.ReactFeatureFlags
import expo.modules.kotlin.events.normalizeEventName
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
import expo.modules.kotlin.modules.Module
import expo.modules.kotlin.modules.ModuleDefinition
import expo.modules.kotlin.uuidv5.InvalidNamespaceException
import expo.modules.kotlin.uuidv5.uuidv5
import java.util.UUID

class CoreModule : Module() {
<<<<<<< HEAD
  private val context: Context
    get() = appContext.reactContext ?: throw Exceptions.AppContextLost()

  override fun definition() = ModuleDefinition {
    Property("expoModulesCoreVersion") {
      return@Property BuildConfig.EXPO_MODULES_CORE_VERSION.let { version ->
        version.split("-")[0].split(".").map { it.toInt() }.let { (major, minor, patch) ->
          mapOf(
            "version" to version,
            "major" to major,
            "minor" to minor,
            "patch" to patch
          )
        }
      }
    }

    Property("cacheDir") {
      return@Property Uri.fromFile(context.cacheDir).toString() + "/"
    }

    Property("documentsDir") {
      return@Property Uri.fromFile(context.filesDir).toString() + "/"
    }

=======
  override fun definition() = ModuleDefinition {
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    // Expose some common classes and maybe even the `modules` host object in the future.
    Function("uuidv4") {
      return@Function UUID.randomUUID().toString()
    }

    Function("uuidv5") { name: String, namespace: String ->
      val namespaceUUID = try {
        UUID.fromString(namespace)
      } catch (e: IllegalArgumentException) {
        throw InvalidNamespaceException(namespace)
      }
      return@Function uuidv5(namespaceUUID, name).toString()
    }

<<<<<<< HEAD
    Function("getViewConfig") { moduleName: String, viewName: String? ->
      val holder = runtimeContext.registry.getModuleHolder(moduleName)
        ?: return@Function null

      val viewManagerDefinition = holder.definition.viewManagerDefinitions[viewName ?: DEFAULT_MODULE_VIEW]
=======
    Function("getViewConfig") { viewName: String ->
      val holder = appContext.registry.getModuleHolder(viewName)
        ?: return@Function null

      val viewManagerDefinition = holder.definition.viewManagerDefinition
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
        ?: return@Function null

      val validAttributes = viewManagerDefinition
        .props
        .keys
        .associateWith { true }

      val directEventTypes = viewManagerDefinition
        .callbacksDefinition
        ?.names
        ?.associate {
          val normalizedEventName = normalizeEventName(it)
          normalizedEventName to mapOf(
            "registrationName" to it
          )
        }

      return@Function mapOf(
        "validAttributes" to validAttributes,
        "directEventTypes" to directEventTypes
      )
    }

    AsyncFunction("reloadAppAsync") { _: String ->
<<<<<<< HEAD
      val reactActivity = appContext.throwingActivity as? ReactActivity ?: return@AsyncFunction
      val reactDelegate = reactActivity.reactDelegate ?: return@AsyncFunction
=======
      val reactActivity = appContext.currentActivity as? ReactActivity ?: return@AsyncFunction

      // TODO(kudo): Use ReactActivity.getReactDelegate() after react-native 0.74.1
      // reactActivity.getReactDelegate()
      val reactActivityDelegateField = ReactActivity::class.java.getDeclaredField("mDelegate")
        .apply { isAccessible = true }
      val reactActivityDelegate = reactActivityDelegateField[reactActivity]
      val getReactDelegateMethod = reactActivityDelegate.javaClass.getDeclaredMethod("getReactDelegate")
        .apply { isAccessible = true }
      val reactDelegate = getReactDelegateMethod.invoke(reactActivityDelegate) as? ReactDelegate
        ?: return@AsyncFunction
      if (!ReactFeatureFlags.enableBridgelessArchitecture) {
        val reactInstanceManager = reactDelegate.reactInstanceManager

        var devSupportManagerClass: Class<*>
        try {
          // react-native version 0.75.0 renamed DisabledDevSupportManager to ReleaseDevSupportManager
          devSupportManagerClass = Class.forName("com.facebook.react.devsupport.ReleaseDevSupportManager")
        } catch (e: ClassNotFoundException) {
          devSupportManagerClass = Class.forName("com.facebook.react.devsupport.DisabledDevSupportManager")
        }
        if (devSupportManagerClass.isInstance(reactInstanceManager.devSupportManager)) {
          UiThreadUtil.runOnUiThread {
            reactInstanceManager.recreateReactContextInBackground()
          }
          return@AsyncFunction
        }
      }

>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
      reactDelegate.reload()
    }
  }
}
