<<<<<<< HEAD
import {
  type EventEmitter as EventEmitterType,
  type EventSubscription,
=======
import type {
  EventEmitter as EventEmitterType,
  EventSubscription,
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
  EventsMap,
} from '../ts-declarations/EventEmitter';
import type { NativeModule as NativeModuleType } from '../ts-declarations/NativeModule';
import type { SharedObject as SharedObjectType } from '../ts-declarations/SharedObject';
<<<<<<< HEAD
import type { SharedRef as SharedRefType } from '../ts-declarations/SharedRef';

export class EventEmitter<TEventsMap extends EventsMap> implements EventEmitterType {
=======
import uuid from '../uuid';

class EventEmitter<TEventsMap extends EventsMap> implements EventEmitterType {
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
  private listeners?: Map<keyof TEventsMap, Set<Function>>;

  addListener<EventName extends keyof TEventsMap>(
    eventName: EventName,
    listener: TEventsMap[EventName]
  ): EventSubscription {
    if (!this.listeners) {
      this.listeners = new Map();
    }
    if (!this.listeners?.has(eventName)) {
      this.listeners?.set(eventName, new Set());
    }
<<<<<<< HEAD

    const previousListenerCount = this.listenerCount(eventName);

    this.listeners?.get(eventName)?.add(listener);

    if (previousListenerCount === 0 && this.listenerCount(eventName) === 1) {
      this.startObserving(eventName);
    }

=======
    this.listeners?.get(eventName)?.add(listener);

>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    return {
      remove: () => {
        this.removeListener(eventName, listener);
      },
    };
  }

  removeListener<EventName extends keyof TEventsMap>(
    eventName: EventName,
    listener: TEventsMap[EventName]
  ): void {
<<<<<<< HEAD
    const hasRemovedListener = this.listeners?.get(eventName)?.delete(listener);
    if (this.listenerCount(eventName) === 0 && hasRemovedListener) {
      this.stopObserving(eventName);
    }
  }

  removeAllListeners<EventName extends keyof TEventsMap>(eventName: EventName): void {
    const previousListenerCount = this.listenerCount(eventName);
    this.listeners?.get(eventName)?.clear();
    if (previousListenerCount > 0) {
      this.stopObserving(eventName);
    }
=======
    this.listeners?.get(eventName)?.delete(listener);
  }

  removeAllListeners<EventName extends keyof TEventsMap>(eventName: EventName): void {
    this.listeners?.get(eventName)?.clear();
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
  }

  emit<EventName extends keyof TEventsMap>(
    eventName: EventName,
    ...args: Parameters<TEventsMap[EventName]>
  ): void {
<<<<<<< HEAD
    const listeners = new Set(this.listeners?.get(eventName));

    listeners.forEach((listener) => {
      // When the listener throws an error, don't stop the execution of subsequent listeners and
      // don't propagate the error to the `emit` function. The motivation behind this is that
      // errors thrown from a module or user's code shouldn't affect other modules' behavior.
      try {
        listener(...args);
      } catch (error) {
        console.error(error);
      }
    });
=======
    this.listeners?.get(eventName)?.forEach((listener) => listener(...args));
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
  }

  listenerCount<EventName extends keyof TEventsMap>(eventName: EventName): number {
    return this.listeners?.get(eventName)?.size ?? 0;
  }
<<<<<<< HEAD

  startObserving<EventName extends keyof TEventsMap>(eventName: EventName): void {}

  stopObserving<EventName extends keyof TEventsMap>(eventName: EventName): void {}
=======
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
}

export class NativeModule<TEventsMap extends Record<never, never>>
  extends EventEmitter<TEventsMap>
  implements NativeModuleType
{
  [key: string]: any;
<<<<<<< HEAD
  ViewPrototypes?: { [viewName: string]: object };
  __expo_module_name__?: string;
}

export class SharedObject<TEventsMap extends Record<never, never>>
=======
  ViewPrototype?: object | undefined;
  __expo_module_name__?: string;
}

class SharedObject<TEventsMap extends Record<never, never>>
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
  extends EventEmitter<TEventsMap>
  implements SharedObjectType
{
  release(): void {
<<<<<<< HEAD
    // no-op on Web, but subclasses can override it if needed.
  }
}

export class SharedRef<
    TNativeRefType extends string = 'unknown',
    TEventsMap extends EventsMap = Record<never, never>,
  >
  extends SharedObject<TEventsMap>
  implements SharedRefType<TNativeRefType>
{
  nativeRefType: string = 'unknown';
}
=======
    throw new Error('Method not implemented.');
  }
}

globalThis.expo = {
  EventEmitter,
  NativeModule,
  SharedObject,
  modules: {},
  uuidv4: uuid.v4,
  uuidv5: uuid.v5,
  getViewConfig: () => {
    throw new Error('Method not implemented.');
  },
  reloadAppAsync: async () => {
    window.location.reload();
  },
};
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
