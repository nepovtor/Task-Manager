"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true,
});
exports.default = void 0;
<<<<<<< HEAD
var _createDevMiddlewareLogger = _interopRequireDefault(
  require("../../utils/createDevMiddlewareLogger")
);
=======
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
var _isDevServerRunning = _interopRequireDefault(
  require("../../utils/isDevServerRunning")
);
var _loadMetroConfig = _interopRequireDefault(
  require("../../utils/loadMetroConfig")
);
<<<<<<< HEAD
var _logger = require("../../utils/logger");
var version = _interopRequireWildcard(require("../../utils/version"));
var _attachKeyHandlers = _interopRequireDefault(require("./attachKeyHandlers"));
var _cliServerApi = require("@react-native-community/cli-server-api");
=======
var _attachKeyHandlers = _interopRequireDefault(require("./attachKeyHandlers"));
var _cliServerApi = require("@react-native-community/cli-server-api");
var _cliTools = require("@react-native-community/cli-tools");
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
var _devMiddleware = require("@react-native/dev-middleware");
var _chalk = _interopRequireDefault(require("chalk"));
var _metro = _interopRequireDefault(require("metro"));
var _metroCore = require("metro-core");
var _path = _interopRequireDefault(require("path"));
var _url = _interopRequireDefault(require("url"));
<<<<<<< HEAD
function _getRequireWildcardCache(e) {
  if ("function" != typeof WeakMap) return null;
  var r = new WeakMap(),
    t = new WeakMap();
  return (_getRequireWildcardCache = function (e) {
    return e ? t : r;
  })(e);
}
function _interopRequireWildcard(e, r) {
  if (!r && e && e.__esModule) return e;
  if (null === e || ("object" != typeof e && "function" != typeof e))
    return { default: e };
  var t = _getRequireWildcardCache(r);
  if (t && t.has(e)) return t.get(e);
  var n = { __proto__: null },
    a = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var u in e)
    if ("default" !== u && {}.hasOwnProperty.call(e, u)) {
      var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
      i && (i.get || i.set) ? Object.defineProperty(n, u, i) : (n[u] = e[u]);
    }
  return (n.default = e), t && t.set(e, n), n;
}
function _interopRequireDefault(e) {
  return e && e.__esModule ? e : { default: e };
}
=======
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *
 * @format
 * @oncall react_native
 */

>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
async function runServer(_argv, ctx, args) {
  const metroConfig = await (0, _loadMetroConfig.default)(ctx, {
    config: args.config,
    maxWorkers: args.maxWorkers,
<<<<<<< HEAD
    port: args.port,
=======
    port: args.port ?? 8081,
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    resetCache: args.resetCache,
    watchFolders: args.watchFolders,
    projectRoot: args.projectRoot,
    sourceExts: args.sourceExts,
  });
  const hostname = args.host?.length ? args.host : "localhost";
  const {
    projectRoot,
    server: { port },
    watchFolders,
  } = metroConfig;
  const protocol = args.https === true ? "https" : "http";
  const devServerUrl = _url.default.format({
    protocol,
    hostname,
    port,
  });
<<<<<<< HEAD
  _logger.logger.info(`Welcome to React Native v${ctx.reactNativeVersion}`);
=======
  _cliTools.logger.info(`Welcome to React Native v${ctx.reactNativeVersion}`);
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
  const serverStatus = await (0, _isDevServerRunning.default)(
    devServerUrl,
    projectRoot
  );
  if (serverStatus === "matched_server_running") {
<<<<<<< HEAD
    _logger.logger.info(
=======
    _cliTools.logger.info(
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
      `A dev server is already running for this project on port ${port}. Exiting.`
    );
    return;
  } else if (serverStatus === "port_taken") {
<<<<<<< HEAD
    _logger.logger.error(
=======
    _cliTools.logger.error(
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
      `Another process is running on port ${port}. Please terminate this ` +
        'process and try again, or use another port with "--port".'
    );
    return;
  }
<<<<<<< HEAD
  _logger.logger.info(
    `Starting dev server on port ${_chalk.default.bold(String(port))}...`
  );
  if (args.assetPlugins) {
=======
  _cliTools.logger.info(
    `Starting dev server on port ${_chalk.default.bold(String(port))}...`
  );
  if (args.assetPlugins) {
    // $FlowIgnore[cannot-write] Assigning to readonly property
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    metroConfig.transformer.assetPlugins = args.assetPlugins.map((plugin) =>
      require.resolve(plugin)
    );
  }
<<<<<<< HEAD
  let reportEvent;
  const terminal = new _metroCore.Terminal(process.stdout);
  const ReporterImpl = getReporterImpl(args.customLogReporterPath);
  const terminalReporter = new ReporterImpl(terminal);
=======
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
  const {
    middleware: communityMiddleware,
    websocketEndpoints: communityWebsocketEndpoints,
    messageSocketEndpoint,
    eventsSocketEndpoint,
  } = (0, _cliServerApi.createDevServerMiddleware)({
    host: hostname,
    port,
    watchFolders,
  });
  const { middleware, websocketEndpoints } = (0,
  _devMiddleware.createDevMiddleware)({
    projectRoot,
    serverBaseUrl: devServerUrl,
<<<<<<< HEAD
    logger: (0, _createDevMiddlewareLogger.default)(terminalReporter),
  });
=======
    logger: _cliTools.logger,
    unstable_experiments: {
      // NOTE: Only affects the /open-debugger endpoint
      enableNewDebugger: args.experimentalDebugger,
    },
  });
  let reportEvent;
  const terminal = new _metroCore.Terminal(process.stdout);
  const ReporterImpl = getReporterImpl(args.customLogReporterPath);
  const terminalReporter = new ReporterImpl(terminal);
  // $FlowIgnore[cannot-write] Assigning to readonly property
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
  metroConfig.reporter = {
    update(event) {
      terminalReporter.update(event);
      if (reportEvent) {
        reportEvent(event);
      }
      if (args.interactive && event.type === "initialize_done") {
<<<<<<< HEAD
        _logger.logger.info("Dev server ready");
=======
        _cliTools.logger.info("Dev server ready");
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
        (0, _attachKeyHandlers.default)({
          cliConfig: ctx,
          devServerUrl,
          messageSocket: messageSocketEndpoint,
<<<<<<< HEAD
          reporter: terminalReporter,
=======
          experimentalDebuggerFrontend: args.experimentalDebugger,
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
        });
      }
    },
  };
  const serverInstance = await _metro.default.runServer(metroConfig, {
    host: args.host,
    secure: args.https,
    secureCert: args.cert,
    secureKey: args.key,
    unstable_extraMiddleware: [
      communityMiddleware,
      _cliServerApi.indexPageMiddleware,
      middleware,
    ],
    websocketEndpoints: {
      ...communityWebsocketEndpoints,
      ...websocketEndpoints,
    },
  });
  reportEvent = eventsSocketEndpoint.reportEvent;
<<<<<<< HEAD
  serverInstance.keepAliveTimeout = 30000;
  await version.logIfUpdateAvailable(ctx.root);
=======

  // In Node 8, the default keep-alive for an HTTP connection is 5 seconds. In
  // early versions of Node 8, this was implemented in a buggy way which caused
  // some HTTP responses (like those containing large JS bundles) to be
  // terminated early.
  //
  // As a workaround, arbitrarily increase the keep-alive from 5 to 30 seconds,
  // which should be enough to send even the largest of JS bundles.
  //
  // For more info: https://github.com/nodejs/node/issues/13391
  //
  serverInstance.keepAliveTimeout = 30000;
  await _cliTools.version.logIfUpdateAvailable(ctx.root);
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
}
function getReporterImpl(customLogReporterPath) {
  if (customLogReporterPath == null) {
    return require("metro/src/lib/TerminalReporter");
  }
  try {
<<<<<<< HEAD
=======
    // First we let require resolve it, so we can require packages in node_modules
    // as expected. eg: require('my-package/reporter');
    // $FlowIgnore[unsupported-syntax]
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    return require(customLogReporterPath);
  } catch (e) {
    if (e.code !== "MODULE_NOT_FOUND") {
      throw e;
    }
<<<<<<< HEAD
    return require(_path.default.resolve(customLogReporterPath));
  }
}
var _default = (exports.default = runServer);
=======
    // If that doesn't work, then we next try relative to the cwd, eg:
    // require('./reporter');
    // $FlowIgnore[unsupported-syntax]
    return require(_path.default.resolve(customLogReporterPath));
  }
}
var _default = runServer;
exports.default = _default;
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
