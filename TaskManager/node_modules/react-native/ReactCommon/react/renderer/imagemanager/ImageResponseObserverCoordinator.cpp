/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#include "ImageResponseObserverCoordinator.h"

#include <algorithm>

#include <react/debug/react_native_assert.h>

namespace facebook::react {

void ImageResponseObserverCoordinator::addObserver(
    const ImageResponseObserver& observer) const {
  mutex_.lock();
  switch (status_) {
    case ImageResponse::Status::Loading: {
      observers_.push_back(&observer);
      mutex_.unlock();
      break;
    }
    case ImageResponse::Status::Completed: {
      auto imageData = imageData_;
      auto imageMetadata = imageMetadata_;
      mutex_.unlock();
      observer.didReceiveImage(ImageResponse{imageData, imageMetadata});
      break;
    }
    case ImageResponse::Status::Failed: {
<<<<<<< HEAD
      auto imageErrorData = imageErrorData_;
      mutex_.unlock();
      observer.didReceiveFailure(ImageLoadError{imageErrorData});
=======
      mutex_.unlock();
      observer.didReceiveFailure();
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
      break;
    }
  }
}

void ImageResponseObserverCoordinator::removeObserver(
    const ImageResponseObserver& observer) const {
  std::scoped_lock lock(mutex_);

  // We remove only one element to maintain a balance between add/remove calls.
  auto position = std::find(observers_.begin(), observers_.end(), &observer);
  if (position != observers_.end()) {
    observers_.erase(position, observers_.end());
  }
}

void ImageResponseObserverCoordinator::nativeImageResponseProgress(
<<<<<<< HEAD
    float progress,
    int64_t loaded,
    int64_t total) const {
=======
    float progress) const {
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
  mutex_.lock();
  auto observers = observers_;
  react_native_assert(status_ == ImageResponse::Status::Loading);
  mutex_.unlock();

  for (auto observer : observers) {
<<<<<<< HEAD
    observer->didReceiveProgress(progress, loaded, total);
=======
    observer->didReceiveProgress(progress);
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
  }
}

void ImageResponseObserverCoordinator::nativeImageResponseComplete(
    const ImageResponse& imageResponse) const {
  mutex_.lock();
  imageData_ = imageResponse.getImage();
  imageMetadata_ = imageResponse.getMetadata();
  react_native_assert(status_ == ImageResponse::Status::Loading);
  status_ = ImageResponse::Status::Completed;
  auto observers = observers_;
  mutex_.unlock();

  for (auto observer : observers_) {
    observer->didReceiveImage(imageResponse);
  }
}

<<<<<<< HEAD
void ImageResponseObserverCoordinator::nativeImageResponseFailed(
    const ImageLoadError& loadError) const {
  mutex_.lock();
  react_native_assert(status_ == ImageResponse::Status::Loading);
  status_ = ImageResponse::Status::Failed;
  imageErrorData_ = loadError.getError();
=======
void ImageResponseObserverCoordinator::nativeImageResponseFailed() const {
  mutex_.lock();
  react_native_assert(status_ == ImageResponse::Status::Loading);
  status_ = ImageResponse::Status::Failed;
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
  auto observers = observers_;
  mutex_.unlock();

  for (auto observer : observers) {
<<<<<<< HEAD
    observer->didReceiveFailure(loadError);
=======
    observer->didReceiveFailure();
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
  }
}

} // namespace facebook::react
