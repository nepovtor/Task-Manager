/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#pragma once

#include <gtest/gtest.h>
#include <hermes/hermes.h>
#include <react/bridging/Bridging.h>

#define EXPECT_JSI_THROW(expr) EXPECT_THROW((expr), facebook::jsi::JSIException)

namespace facebook::react {

class TestCallInvoker : public CallInvoker {
 public:
<<<<<<< HEAD
  void invokeAsync(CallFunc&& fn) noexcept override {
    queue_.push_back(std::move(fn));
  }

  void invokeSync(CallFunc&&) override {
=======
  void invokeAsync(std::function<void()>&& fn) noexcept override {
    queue_.push_back(std::move(fn));
  }

  void invokeSync(std::function<void()>&&) override {
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    FAIL() << "JSCallInvoker does not support invokeSync()";
  }

 private:
  friend class BridgingTest;

<<<<<<< HEAD
  std::list<CallFunc> queue_;
=======
  std::list<std::function<void()>> queue_;
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
};

class BridgingTest : public ::testing::Test {
 protected:
  BridgingTest()
      : invoker(std::make_shared<TestCallInvoker>()),
        runtime(hermes::makeHermesRuntime(
            ::hermes::vm::RuntimeConfig::Builder()
                // Make promises work with Hermes microtasks.
                .withMicrotaskQueue(true)
                .build())),
        rt(*runtime) {}

  ~BridgingTest() {
<<<<<<< HEAD
    LongLivedObjectCollection::get(rt).clear();
=======
    LongLivedObjectCollection::get().clear();
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
  }

  void TearDown() override {
    flushQueue();

    // After flushing the invoker queue, we shouldn't leak memory.
<<<<<<< HEAD
    EXPECT_EQ(0, LongLivedObjectCollection::get(rt).size());
=======
    EXPECT_EQ(0, LongLivedObjectCollection::get().size());
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
  }

  jsi::Value eval(const std::string& js) {
    return rt.global().getPropertyAsFunction(rt, "eval").call(rt, js);
  }

  jsi::Function function(const std::string& js) {
    return eval(("(" + js + ")").c_str()).getObject(rt).getFunction(rt);
  }

  void flushQueue() {
    while (!invoker->queue_.empty()) {
<<<<<<< HEAD
      invoker->queue_.front()(*runtime);
=======
      invoker->queue_.front()();
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
      invoker->queue_.pop_front();
      rt.drainMicrotasks(); // Run microtasks every cycle.
    }
  }

  std::shared_ptr<TestCallInvoker> invoker;
  std::unique_ptr<jsi::Runtime> runtime;
  jsi::Runtime& rt;
};

} // namespace facebook::react
