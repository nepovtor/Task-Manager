/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow strict-local
 * @format
 */

<<<<<<< HEAD
import type {TextStyleProp} from '../StyleSheet/StyleSheet';
import type {____TextStyle_Internal as TextStyleInternal} from '../StyleSheet/StyleSheetTypes';
import type {PressEvent} from '../Types/CoreEventTypes';
import type {NativeTextProps} from './TextNativeComponent';
import type {PressRetentionOffset, TextProps} from './TextProps';
=======
import type {PressEvent} from '../Types/CoreEventTypes';
import type {TextProps} from './TextProps';
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251

import * as PressabilityDebug from '../Pressability/PressabilityDebug';
import usePressability from '../Pressability/usePressability';
import flattenStyle from '../StyleSheet/flattenStyle';
import processColor from '../StyleSheet/processColor';
import Platform from '../Utilities/Platform';
import TextAncestor from './TextAncestor';
import {NativeText, NativeVirtualText} from './TextNativeComponent';
import * as React from 'react';
import {useContext, useMemo, useState} from 'react';

<<<<<<< HEAD
type TextForwardRef = React.ElementRef<
  typeof NativeText | typeof NativeVirtualText,
>;

=======
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
/**
 * Text is the fundamental component for displaying text.
 *
 * @see https://reactnative.dev/docs/text
 */
<<<<<<< HEAD
const Text: React.AbstractComponent<TextProps, TextForwardRef> =
  React.forwardRef(
    (
      {
        accessible,
        accessibilityLabel,
        accessibilityState,
        allowFontScaling,
        'aria-busy': ariaBusy,
        'aria-checked': ariaChecked,
        'aria-disabled': ariaDisabled,
        'aria-expanded': ariaExpanded,
        'aria-label': ariaLabel,
        'aria-selected': ariaSelected,
        children,
        ellipsizeMode,
        disabled,
        id,
        nativeID,
        numberOfLines,
        onLongPress,
        onPress,
        onPressIn,
        onPressOut,
        onResponderGrant,
        onResponderMove,
        onResponderRelease,
        onResponderTerminate,
        onResponderTerminationRequest,
        onStartShouldSetResponder,
        pressRetentionOffset,
        selectable,
        selectionColor,
        suppressHighlighting,
        style,
        ...restProps
      }: TextProps,
      forwardedRef,
    ) => {
      const _accessibilityLabel = ariaLabel ?? accessibilityLabel;

      let _accessibilityState: ?TextProps['accessibilityState'] =
        accessibilityState;
      if (
        ariaBusy != null ||
        ariaChecked != null ||
        ariaDisabled != null ||
        ariaExpanded != null ||
        ariaSelected != null
      ) {
        if (_accessibilityState != null) {
          _accessibilityState = {
            busy: ariaBusy ?? _accessibilityState.busy,
            checked: ariaChecked ?? _accessibilityState.checked,
            disabled: ariaDisabled ?? _accessibilityState.disabled,
            expanded: ariaExpanded ?? _accessibilityState.expanded,
            selected: ariaSelected ?? _accessibilityState.selected,
          };
        } else {
          _accessibilityState = {
            busy: ariaBusy,
            checked: ariaChecked,
            disabled: ariaDisabled,
            expanded: ariaExpanded,
            selected: ariaSelected,
          };
        }
      }

      const _accessibilityStateDisabled = _accessibilityState?.disabled;
      const _disabled = disabled ?? _accessibilityStateDisabled;

      const isPressable =
        (onPress != null ||
          onLongPress != null ||
          onStartShouldSetResponder != null) &&
        _disabled !== true;

      // TODO: Move this processing to the view configuration.
      const _selectionColor =
        selectionColor == null ? null : processColor(selectionColor);

      let _style = style;
      if (__DEV__) {
        if (PressabilityDebug.isEnabled() && onPress != null) {
          _style = [style, {color: 'magenta'}];
        }
      }

      let _numberOfLines = numberOfLines;
      if (_numberOfLines != null && !(_numberOfLines >= 0)) {
        if (__DEV__) {
          console.error(
            `'numberOfLines' in <Text> must be a non-negative number, received: ${_numberOfLines}. The value will be set to 0.`,
          );
        }
        _numberOfLines = 0;
      }

      let _selectable = selectable;

      let processedStyle = flattenStyle<TextStyleProp>(_style);
      if (processedStyle != null) {
        let overrides: ?{...TextStyleInternal} = null;
        if (typeof processedStyle.fontWeight === 'number') {
          overrides = overrides || ({}: {...TextStyleInternal});
          overrides.fontWeight =
            // $FlowFixMe[incompatible-cast]
            (processedStyle.fontWeight.toString(): TextStyleInternal['fontWeight']);
        }

        if (processedStyle.userSelect != null) {
          _selectable = userSelectToSelectableMap[processedStyle.userSelect];
          overrides = overrides || ({}: {...TextStyleInternal});
          overrides.userSelect = undefined;
        }

        if (processedStyle.verticalAlign != null) {
          overrides = overrides || ({}: {...TextStyleInternal});
          overrides.textAlignVertical =
            verticalAlignToTextAlignVerticalMap[processedStyle.verticalAlign];
          overrides.verticalAlign = undefined;
        }

        if (overrides != null) {
          // $FlowFixMe[incompatible-type]
          _style = [_style, overrides];
        }
      }

      const _nativeID = id ?? nativeID;

      const hasTextAncestor = useContext(TextAncestor);
      if (hasTextAncestor) {
        if (isPressable) {
          return (
            <NativePressableVirtualText
              ref={forwardedRef}
              textProps={{
                ...restProps,
                accessibilityLabel: _accessibilityLabel,
                accessibilityState: _accessibilityState,
                nativeID: _nativeID,
                numberOfLines: _numberOfLines,
                selectable: _selectable,
                selectionColor: _selectionColor,
                style: _style,
                disabled: disabled,
                children,
              }}
              textPressabilityProps={{
                onLongPress,
                onPress,
                onPressIn,
                onPressOut,
                onResponderGrant,
                onResponderMove,
                onResponderRelease,
                onResponderTerminate,
                onResponderTerminationRequest,
                onStartShouldSetResponder,
                pressRetentionOffset,
                suppressHighlighting,
              }}
            />
          );
        }

        return (
          <NativeVirtualText
            {...restProps}
            accessibilityLabel={_accessibilityLabel}
            accessibilityState={_accessibilityState}
            isHighlighted={false}
            isPressable={false}
            nativeID={_nativeID}
            numberOfLines={_numberOfLines}
            ref={forwardedRef}
            selectable={_selectable}
            selectionColor={_selectionColor}
            style={_style}
            disabled={disabled}>
            {children}
          </NativeVirtualText>
        );
      }

      // If the disabled prop and accessibilityState.disabled are out of sync but not both in
      // falsy states we need to update the accessibilityState object to use the disabled prop.
      if (
        _disabled !== _accessibilityStateDisabled &&
        ((_disabled != null && _disabled !== false) ||
          (_accessibilityStateDisabled != null &&
            _accessibilityStateDisabled !== false))
      ) {
        _accessibilityState = {..._accessibilityState, disabled: _disabled};
      }

      const _accessible = Platform.select({
        ios: accessible !== false,
        android:
          accessible == null
            ? onPress != null || onLongPress != null
            : accessible,
        default: accessible,
      });

      let nativeText = null;
      if (isPressable) {
        nativeText = (
          <NativePressableText
            ref={forwardedRef}
            textProps={{
              ...restProps,
              accessibilityLabel: _accessibilityLabel,
              accessibilityState: _accessibilityState,
              accessible: _accessible,
              allowFontScaling: allowFontScaling !== false,
              disabled: _disabled,
              ellipsizeMode: ellipsizeMode ?? 'tail',
              nativeID: _nativeID,
              numberOfLines: _numberOfLines,
              selectable: _selectable,
              selectionColor: _selectionColor,
              style: _style,
              children,
            }}
            textPressabilityProps={{
              onLongPress,
              onPress,
              onPressIn,
              onPressOut,
              onResponderGrant,
              onResponderMove,
              onResponderRelease,
              onResponderTerminate,
              onResponderTerminationRequest,
              onStartShouldSetResponder,
              pressRetentionOffset,
              suppressHighlighting,
            }}
          />
        );
      } else {
        nativeText = (
          <NativeText
            {...restProps}
            accessibilityLabel={_accessibilityLabel}
            accessibilityState={_accessibilityState}
            accessible={_accessible}
            allowFontScaling={allowFontScaling !== false}
            disabled={_disabled}
            ellipsizeMode={ellipsizeMode ?? 'tail'}
            isHighlighted={false}
            nativeID={_nativeID}
            numberOfLines={_numberOfLines}
            ref={forwardedRef}
            selectable={_selectable}
            selectionColor={_selectionColor}
            style={_style}>
            {children}
          </NativeText>
        );
      }

      if (children == null) {
        return nativeText;
      }

      // If the children do not contain a JSX element it would not be possible to have a
      // nested `Text` component so we can skip adding the `TextAncestor` context wrapper
      // which has a performance overhead. Since we do this for performance reasons we need
      // to keep the check simple to avoid regressing overall perf. For this reason the
      // `children.length` constant is set to `3`, this should be a reasonable tradeoff
      // to capture the majority of `Text` uses but also not make this check too expensive.
      if (Array.isArray(children) && children.length <= 3) {
        let hasNonTextChild = false;
        for (let child of children) {
          if (child != null && typeof child === 'object') {
            hasNonTextChild = true;
            break;
          }
        }
        if (!hasNonTextChild) {
          return nativeText;
        }
      } else if (typeof children !== 'object') {
        return nativeText;
      }

      return (
        <TextAncestor.Provider value={true}>{nativeText}</TextAncestor.Provider>
      );
    },
  );

Text.displayName = 'Text';

type TextPressabilityProps = $ReadOnly<{
  onLongPress?: ?(event: PressEvent) => mixed,
  onPress?: ?(event: PressEvent) => mixed,
  onPressIn?: ?(event: PressEvent) => mixed,
  onPressOut?: ?(event: PressEvent) => mixed,
  onResponderGrant?: ?(event: PressEvent) => void,
  onResponderMove?: ?(event: PressEvent) => void,
  onResponderRelease?: ?(event: PressEvent) => void,
  onResponderTerminate?: ?(event: PressEvent) => void,
  onResponderTerminationRequest?: ?() => boolean,
  onStartShouldSetResponder?: ?() => boolean,
  pressRetentionOffset?: ?PressRetentionOffset,
  suppressHighlighting?: ?boolean,
}>;

/**
 * Hook that handles setting up Pressability of Text components.
 *
 * NOTE: This hook is relatively expensive so it should only be used absolutely necessary.
 */
function useTextPressability({
  onLongPress,
  onPress,
  onPressIn,
  onPressOut,
  onResponderGrant,
  onResponderMove,
  onResponderRelease,
  onResponderTerminate,
  onResponderTerminationRequest,
  onStartShouldSetResponder,
  pressRetentionOffset,
  suppressHighlighting,
}: TextPressabilityProps) {
  const [isHighlighted, setHighlighted] = useState(false);

  // Setup pressability config and wrap callbacks needs to track the highlight state.
  const config = useMemo(() => {
    let _onPressIn = onPressIn;
    let _onPressOut = onPressOut;

    // Updating isHighlighted causes unnecessary re-renders for platforms that don't use it
    // in the best case, and cause issues with text selection in the worst case. Forcing
    // the isHighlighted prop to false on all platforms except iOS.
    if (Platform.OS === 'ios') {
      _onPressIn = (event: PressEvent) => {
        setHighlighted(suppressHighlighting == null || !suppressHighlighting);
        onPressIn?.(event);
      };

      _onPressOut = (event: PressEvent) => {
        setHighlighted(false);
        onPressOut?.(event);
      };
    }

    return {
      disabled: false,
      pressRectOffset: pressRetentionOffset,
      onLongPress,
      onPress,
      onPressIn: _onPressIn,
      onPressOut: _onPressOut,
    };
  }, [
    pressRetentionOffset,
=======
const Text: React.AbstractComponent<
  TextProps,
  React.ElementRef<typeof NativeText | typeof NativeVirtualText>,
> = React.forwardRef((props: TextProps, forwardedRef) => {
  const {
    accessible,
    accessibilityLabel,
    accessibilityState,
    allowFontScaling,
    'aria-busy': ariaBusy,
    'aria-checked': ariaChecked,
    'aria-disabled': ariaDisabled,
    'aria-expanded': ariaExpanded,
    'aria-label': ariaLabel,
    'aria-selected': ariaSelected,
    ellipsizeMode,
    id,
    nativeID,
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    onLongPress,
    onPress,
    onPressIn,
    onPressOut,
<<<<<<< HEAD
    suppressHighlighting,
  ]);

  // Init the pressability class
  const eventHandlers = usePressability(config);

  // Create NativeText event handlers which proxy events to pressability
=======
    onResponderGrant,
    onResponderMove,
    onResponderRelease,
    onResponderTerminate,
    onResponderTerminationRequest,
    onStartShouldSetResponder,
    pressRetentionOffset,
    suppressHighlighting,
    ...restProps
  } = props;

  const [isHighlighted, setHighlighted] = useState(false);

  let _accessibilityState;
  if (
    accessibilityState != null ||
    ariaBusy != null ||
    ariaChecked != null ||
    ariaDisabled != null ||
    ariaExpanded != null ||
    ariaSelected != null
  ) {
    _accessibilityState = {
      busy: ariaBusy ?? accessibilityState?.busy,
      checked: ariaChecked ?? accessibilityState?.checked,
      disabled: ariaDisabled ?? accessibilityState?.disabled,
      expanded: ariaExpanded ?? accessibilityState?.expanded,
      selected: ariaSelected ?? accessibilityState?.selected,
    };
  }

  const _disabled =
    restProps.disabled != null
      ? restProps.disabled
      : _accessibilityState?.disabled;

  const nativeTextAccessibilityState =
    _disabled !== _accessibilityState?.disabled
      ? {..._accessibilityState, disabled: _disabled}
      : _accessibilityState;

  const isPressable =
    (onPress != null ||
      onLongPress != null ||
      onStartShouldSetResponder != null) &&
    _disabled !== true;

  const initialized = useLazyInitialization(isPressable);
  const config = useMemo(
    () =>
      initialized
        ? {
            disabled: !isPressable,
            pressRectOffset: pressRetentionOffset,
            onLongPress,
            onPress,
            onPressIn(event: PressEvent) {
              // Updating isHighlighted causes unnecessary re-renders for platforms that don't use it
              // in the best case, and cause issues with text selection in the worst case. Forcing
              // the isHighlighted prop to false on all platforms except iOS.
              setHighlighted(
                (suppressHighlighting == null || !suppressHighlighting) &&
                  Platform.OS === 'ios',
              );
              onPressIn?.(event);
            },
            onPressOut(event: PressEvent) {
              setHighlighted(false);
              onPressOut?.(event);
            },
            onResponderTerminationRequest_DEPRECATED:
              onResponderTerminationRequest,
            onStartShouldSetResponder_DEPRECATED: onStartShouldSetResponder,
          }
        : null,
    [
      initialized,
      isPressable,
      pressRetentionOffset,
      onLongPress,
      onPress,
      onPressIn,
      onPressOut,
      onResponderTerminationRequest,
      onStartShouldSetResponder,
      suppressHighlighting,
    ],
  );

  const eventHandlers = usePressability(config);
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
  const eventHandlersForText = useMemo(
    () =>
      eventHandlers == null
        ? null
        : {
            onResponderGrant(event: PressEvent) {
              eventHandlers.onResponderGrant(event);
              if (onResponderGrant != null) {
                onResponderGrant(event);
              }
            },
            onResponderMove(event: PressEvent) {
              eventHandlers.onResponderMove(event);
              if (onResponderMove != null) {
                onResponderMove(event);
              }
            },
            onResponderRelease(event: PressEvent) {
              eventHandlers.onResponderRelease(event);
              if (onResponderRelease != null) {
                onResponderRelease(event);
              }
            },
            onResponderTerminate(event: PressEvent) {
              eventHandlers.onResponderTerminate(event);
              if (onResponderTerminate != null) {
                onResponderTerminate(event);
              }
            },
            onClick: eventHandlers.onClick,
            onResponderTerminationRequest:
<<<<<<< HEAD
              onResponderTerminationRequest != null
                ? onResponderTerminationRequest
                : eventHandlers.onResponderTerminationRequest,
            onStartShouldSetResponder:
              onStartShouldSetResponder != null
                ? onStartShouldSetResponder
                : eventHandlers.onStartShouldSetResponder,
=======
              eventHandlers.onResponderTerminationRequest,
            onStartShouldSetResponder: eventHandlers.onStartShouldSetResponder,
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
          },
    [
      eventHandlers,
      onResponderGrant,
      onResponderMove,
      onResponderRelease,
      onResponderTerminate,
<<<<<<< HEAD
      onResponderTerminationRequest,
      onStartShouldSetResponder,
    ],
  );

  // Return the highlight state and NativeText event handlers
  return useMemo(
    () => [isHighlighted, eventHandlersForText],
    [isHighlighted, eventHandlersForText],
  );
}

type NativePressableTextProps = $ReadOnly<{
  textProps: NativeTextProps,
  textPressabilityProps: TextPressabilityProps,
}>;

/**
 * Wrap the NativeVirtualText component and initialize pressability.
 *
 * This logic is split out from the main Text component to enable the more
 * expensive pressability logic to be only initialized when needed.
 */
const NativePressableVirtualText: React.AbstractComponent<
  NativePressableTextProps,
  TextForwardRef,
> = React.forwardRef(({textProps, textPressabilityProps}, forwardedRef) => {
  const [isHighlighted, eventHandlersForText] = useTextPressability(
    textPressabilityProps,
  );

  return (
    <NativeVirtualText
      {...textProps}
      {...eventHandlersForText}
      isHighlighted={isHighlighted}
      isPressable={true}
      ref={forwardedRef}
    />
  );
});

/**
 * Wrap the NativeText component and initialize pressability.
 *
 * This logic is split out from the main Text component to enable the more
 * expensive pressability logic to be only initialized when needed.
 */
const NativePressableText: React.AbstractComponent<
  NativePressableTextProps,
  TextForwardRef,
> = React.forwardRef(({textProps, textPressabilityProps}, forwardedRef) => {
  const [isHighlighted, eventHandlersForText] = useTextPressability(
    textPressabilityProps,
  );

  return (
    <NativeText
      {...textProps}
      {...eventHandlersForText}
      isHighlighted={isHighlighted}
      isPressable={true}
      ref={forwardedRef}
    />
  );
});
=======
    ],
  );

  // TODO: Move this processing to the view configuration.
  const selectionColor =
    restProps.selectionColor == null
      ? null
      : processColor(restProps.selectionColor);

  let style = restProps.style;

  if (__DEV__) {
    if (PressabilityDebug.isEnabled() && onPress != null) {
      style = [restProps.style, {color: 'magenta'}];
    }
  }

  let numberOfLines = restProps.numberOfLines;
  if (numberOfLines != null && !(numberOfLines >= 0)) {
    console.error(
      `'numberOfLines' in <Text> must be a non-negative number, received: ${numberOfLines}. The value will be set to 0.`,
    );
    numberOfLines = 0;
  }

  const hasTextAncestor = useContext(TextAncestor);

  const _accessible = Platform.select({
    ios: accessible !== false,
    default: accessible,
  });

  // $FlowFixMe[underconstrained-implicit-instantiation]
  style = flattenStyle(style);

  if (typeof style?.fontWeight === 'number') {
    // $FlowFixMe[prop-missing]
    // $FlowFixMe[cannot-write]
    style.fontWeight = style?.fontWeight.toString();
  }

  let _selectable = restProps.selectable;
  if (style?.userSelect != null) {
    // $FlowFixMe[invalid-computed-prop]
    _selectable = userSelectToSelectableMap[style.userSelect];
    // $FlowFixMe[prop-missing]
    // $FlowFixMe[cannot-write]
    delete style.userSelect;
  }

  if (style?.verticalAlign != null) {
    // $FlowFixMe[prop-missing]
    // $FlowFixMe[cannot-write]
    style.textAlignVertical =
      // $FlowFixMe[invalid-computed-prop]
      verticalAlignToTextAlignVerticalMap[style.verticalAlign];
    // $FlowFixMe[prop-missing]
    // $FlowFixMe[cannot-write]
    delete style.verticalAlign;
  }

  const _hasOnPressOrOnLongPress =
    props.onPress != null || props.onLongPress != null;

  return hasTextAncestor ? (
    <NativeVirtualText
      {...restProps}
      {...eventHandlersForText}
      accessibilityLabel={ariaLabel ?? accessibilityLabel}
      accessibilityState={_accessibilityState}
      isHighlighted={isHighlighted}
      isPressable={isPressable}
      nativeID={id ?? nativeID}
      numberOfLines={numberOfLines}
      ref={forwardedRef}
      selectable={_selectable}
      selectionColor={selectionColor}
      style={style}
    />
  ) : (
    <TextAncestor.Provider value={true}>
      <NativeText
        {...restProps}
        {...eventHandlersForText}
        accessibilityLabel={ariaLabel ?? accessibilityLabel}
        accessibilityState={nativeTextAccessibilityState}
        accessible={
          accessible == null && Platform.OS === 'android'
            ? _hasOnPressOrOnLongPress
            : _accessible
        }
        allowFontScaling={allowFontScaling !== false}
        disabled={_disabled}
        ellipsizeMode={ellipsizeMode ?? 'tail'}
        isHighlighted={isHighlighted}
        nativeID={id ?? nativeID}
        numberOfLines={numberOfLines}
        ref={forwardedRef}
        selectable={_selectable}
        selectionColor={selectionColor}
        style={style}
      />
    </TextAncestor.Provider>
  );
});

Text.displayName = 'Text';

/**
 * Returns false until the first time `newValue` is true, after which this will
 * always return true. This is necessary to lazily initialize `Pressability` so
 * we do not eagerly create one for every pressable `Text` component.
 */
function useLazyInitialization(newValue: boolean): boolean {
  const [oldValue, setValue] = useState(newValue);
  if (!oldValue && newValue) {
    setValue(newValue);
  }
  return oldValue;
}
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251

const userSelectToSelectableMap = {
  auto: true,
  text: true,
  none: false,
  contain: true,
  all: true,
};

const verticalAlignToTextAlignVerticalMap = {
  auto: 'auto',
  top: 'top',
  bottom: 'bottom',
  middle: 'center',
};

module.exports = Text;
