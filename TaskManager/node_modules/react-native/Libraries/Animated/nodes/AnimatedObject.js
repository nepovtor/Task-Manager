/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 * @format
 * @oncall react_native
 */

'use strict';

import type {PlatformConfig} from '../AnimatedPlatformConfig';

import AnimatedNode from './AnimatedNode';
import AnimatedWithChildren from './AnimatedWithChildren';
import * as React from 'react';

const MAX_DEPTH = 5;

<<<<<<< HEAD
/* $FlowIssue[incompatible-type-guard] - Flow does not know that the prototype
   and ReactElement checks preserve the type refinement of `value`. */
function isPlainObject(value: mixed): value is $ReadOnly<{[string]: mixed}> {
  return (
    value !== null &&
    typeof value === 'object' &&
    Object.getPrototypeOf(value).isPrototypeOf(Object) &&
    !React.isValidElement(value)
  );
}

function flatAnimatedNodes(
  value: mixed,
  nodes: Array<AnimatedNode> = [],
  depth: number = 0,
): Array<AnimatedNode> {
  if (depth >= MAX_DEPTH) {
    return nodes;
  }
  if (value instanceof AnimatedNode) {
    nodes.push(value);
  } else if (Array.isArray(value)) {
    for (let ii = 0, length = value.length; ii < length; ii++) {
      const element = value[ii];
      flatAnimatedNodes(element, nodes, depth + 1);
    }
  } else if (isPlainObject(value)) {
    const keys = Object.keys(value);
    for (let ii = 0, length = keys.length; ii < length; ii++) {
      const key = keys[ii];
      flatAnimatedNodes(value[key], nodes, depth + 1);
    }
  }
  return nodes;
=======
function isPlainObject(value: any): boolean {
  return (
    value !== null &&
    typeof value === 'object' &&
    Object.getPrototypeOf(value).isPrototypeOf(Object)
  );
}

// Recurse through values, executing fn for any AnimatedNodes
function visit(value: any, fn: any => void, depth: number = 0): void {
  if (depth >= MAX_DEPTH) {
    return;
  }

  if (value instanceof AnimatedNode) {
    fn(value);
  } else if (Array.isArray(value)) {
    value.forEach(element => {
      visit(element, fn, depth + 1);
    });
  } else if (isPlainObject(value)) {
    Object.values(value).forEach(element => {
      visit(element, fn, depth + 1);
    });
  }
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
}

// Returns a copy of value with a transformation fn applied to any AnimatedNodes
function mapAnimatedNodes(value: any, fn: any => any, depth: number = 0): any {
  if (depth >= MAX_DEPTH) {
    return value;
  }

  if (value instanceof AnimatedNode) {
    return fn(value);
  } else if (Array.isArray(value)) {
    return value.map(element => mapAnimatedNodes(element, fn, depth + 1));
  } else if (isPlainObject(value)) {
    const result: {[string]: any} = {};
<<<<<<< HEAD
    const keys = Object.keys(value);
    for (let ii = 0, length = keys.length; ii < length; ii++) {
      const key = keys[ii];
=======
    for (const key in value) {
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
      result[key] = mapAnimatedNodes(value[key], fn, depth + 1);
    }
    return result;
  } else {
    return value;
  }
}

<<<<<<< HEAD
export default class AnimatedObject extends AnimatedWithChildren {
  #nodes: $ReadOnlyArray<AnimatedNode>;
  _value: mixed;

  /**
   * Creates an `AnimatedObject` if `value` contains `AnimatedNode` instances.
   * Otherwise, returns `null`.
   */
  static from(value: mixed): ?AnimatedObject {
    const nodes = flatAnimatedNodes(value);
    if (nodes.length === 0) {
      return null;
    }
    return new AnimatedObject(nodes, value);
  }

  /**
   * Should only be called by `AnimatedObject.from`.
   */
  constructor(nodes: $ReadOnlyArray<AnimatedNode>, value: mixed) {
    super();
    this.#nodes = nodes;
=======
export function hasAnimatedNode(value: any, depth: number = 0): boolean {
  if (depth >= MAX_DEPTH) {
    return false;
  }

  if (value instanceof AnimatedNode) {
    return true;
  } else if (Array.isArray(value)) {
    for (const element of value) {
      if (hasAnimatedNode(element, depth + 1)) {
        return true;
      }
    }
  } else if (isPlainObject(value)) {
    // Don't consider React elements
    if (React.isValidElement(value)) {
      return false;
    }
    for (const key in value) {
      if (hasAnimatedNode(value[key], depth + 1)) {
        return true;
      }
    }
  }
  return false;
}

export default class AnimatedObject extends AnimatedWithChildren {
  _value: any;

  constructor(value: any) {
    super();
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    this._value = value;
  }

  __getValue(): any {
    return mapAnimatedNodes(this._value, node => {
      return node.__getValue();
    });
  }

  __getAnimatedValue(): any {
    return mapAnimatedNodes(this._value, node => {
      return node.__getAnimatedValue();
    });
  }

  __attach(): void {
<<<<<<< HEAD
    const nodes = this.#nodes;
    for (let ii = 0, length = nodes.length; ii < length; ii++) {
      const node = nodes[ii];
      node.__addChild(this);
    }
  }

  __detach(): void {
    const nodes = this.#nodes;
    for (let ii = 0, length = nodes.length; ii < length; ii++) {
      const node = nodes[ii];
      node.__removeChild(this);
    }
=======
    super.__attach();
    visit(this._value, node => {
      node.__addChild(this);
    });
  }

  __detach(): void {
    visit(this._value, node => {
      node.__removeChild(this);
    });
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    super.__detach();
  }

  __makeNative(platformConfig: ?PlatformConfig): void {
<<<<<<< HEAD
    const nodes = this.#nodes;
    for (let ii = 0, length = nodes.length; ii < length; ii++) {
      const node = nodes[ii];
      node.__makeNative(platformConfig);
    }
=======
    visit(this._value, value => {
      value.__makeNative(platformConfig);
    });
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
    super.__makeNative(platformConfig);
  }

  __getNativeConfig(): any {
    return {
      type: 'object',
      value: mapAnimatedNodes(this._value, node => {
        return {nodeTag: node.__getNativeTag()};
      }),
    };
  }
}
