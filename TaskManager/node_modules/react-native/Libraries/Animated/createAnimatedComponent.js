/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 * @format
 */

<<<<<<< HEAD
import composeStyles from '../../src/private/styles/composeStyles';
=======
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
import View from '../Components/View/View';
import useMergeRefs from '../Utilities/useMergeRefs';
import useAnimatedProps from './useAnimatedProps';
import * as React from 'react';
<<<<<<< HEAD
import {useMemo} from 'react';

export type AnimatedProps<Props: {...}> = {
  // eslint-disable-next-line no-unused-vars
  +[_K in keyof (Props &
      $ReadOnly<{
        passthroughAnimatedPropExplicitValues?: React.ElementConfig<
          typeof View,
        >,
      }>)]: any,
};
=======

// $FlowFixMe[deprecated-type]
export type AnimatedProps<Props: {...}> = $ObjMap<
  Props &
    $ReadOnly<{
      passthroughAnimatedPropExplicitValues?: React.ElementConfig<typeof View>,
    }>,
  () => any,
>;
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251

export type AnimatedComponentType<
  Props: {...},
  +Instance = mixed,
> = React.AbstractComponent<AnimatedProps<Props>, Instance>;

export default function createAnimatedComponent<TProps: {...}, TInstance>(
  Component: React.AbstractComponent<TProps, TInstance>,
): AnimatedComponentType<TProps, TInstance> {
  const AnimatedComponent = React.forwardRef<AnimatedProps<TProps>, TInstance>(
    (props, forwardedRef) => {
      const [reducedProps, callbackRef] = useAnimatedProps<TProps, TInstance>(
        // $FlowFixMe[incompatible-call]
        props,
      );
      const ref = useMergeRefs<TInstance>(callbackRef, forwardedRef);

      // Some components require explicit passthrough values for animation
      // to work properly. For example, if an animated component is
      // transformed and Pressable, onPress will not work after transform
      // without these passthrough values.
      // $FlowFixMe[prop-missing]
      const {passthroughAnimatedPropExplicitValues, style} = reducedProps;
<<<<<<< HEAD
      const passthroughStyle = passthroughAnimatedPropExplicitValues?.style;
      const mergedStyle = useMemo(
        () => composeStyles(style, passthroughStyle),
        [passthroughStyle, style],
      );

      // NOTE: It is important that `passthroughAnimatedPropExplicitValues` is
      // spread after `reducedProps` but before `style`.
      return (
        <Component
          {...reducedProps}
          {...passthroughAnimatedPropExplicitValues}
=======
      const {style: passthroughStyle, ...passthroughProps} =
        passthroughAnimatedPropExplicitValues ?? {};
      const mergedStyle = {...style, ...passthroughStyle};

      return (
        <Component
          {...reducedProps}
          {...passthroughProps}
>>>>>>> 0823204efb84884a0322b43e865bb36631ba8251
          style={mergedStyle}
          ref={ref}
        />
      );
    },
  );

  AnimatedComponent.displayName = `Animated(${
    Component.displayName || 'Anonymous'
  })`;

  return AnimatedComponent;
}
